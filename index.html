<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Master Helper</title>
    <!-- Embedded CSS for complete single-file solution (replacing Tailwind) -->
    <style>
        /* Reset and base styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Cinzel', 'Book Antiqua', 'Palatino Linotype', serif; 
            background: 
                radial-gradient(circle at 20% 50%, rgba(139, 69, 19, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(160, 82, 45, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(101, 67, 33, 0.25) 0%, transparent 50%),
                linear-gradient(135deg, #2d1810 0%, #3d2817 25%, #4a321e 50%, #2d1810 75%, #1a0f08 100%);
            color: #f4f1e8; 
            min-height: 100vh;
            background-attachment: fixed;
            position: relative;
        }
        
        /* Parchment texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="paper"><feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="5" result="noise"/><feDiffuseLighting in="noise" lighting-color="white" surfaceScale="1"><feDistantLight azimuth="45" elevation="60"/></feDiffuseLighting></filter></defs><rect width="100%" height="100%" filter="url(%23paper)" opacity="0.4"/></svg>'),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(139, 69, 19, 0.1) 3px),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(160, 82, 45, 0.05) 3px);
            opacity: 0.6;
            pointer-events: none;
            z-index: -1;
        }
        
        /* Typography - Optimized medieval/fantasy stack for D&D aesthetic */
        @font-face {
            font-family: 'Cinzel';
            src: url('data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAAAdsAAoAAAAAGOAAAAciAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFQGYACEXAqYQJZVATYCJAM4CywABCAFhAIHcBssFCOyI8WYVaBsm8wBu4aDaOcgHoSHzUTpGQ/8r9++857Wjw8C0AwCJCiQIBBAFAhsGl5WLQ/UYmbdWp4DUxpJokSSOGkkjRpJk0aaJEFQIhQ3QdAiCFpQItQkSZMgSJMEQZMEQdMEQZMEQdMEQdMEQdMEQdMEQdMEQdMEQdMkSZMkSZJEkiRJpJEkiRpJm0iRJBEFQRBULQ1VJYlAoIqBQLFgIFQtGAgUCwaq1gylDQNVBQYCxYKBUIFgoIrFoECxYKBaMJCOYiAQqBoGAoEGQdBaGgJBlkCRaRkEQZUEQdMEQZMEQdMEQdMEQYkgCJokiSRJEknjRtJE2kSaRJpEmkSaRJpEmkSaRJpImkSaRJJEkiSRRJJGkkmSJEkljSRNJE2kTaRJpImkiRRJm0iTSJNIk0iTSJNIk0iTSJJIkkiSRJJIkkmSJJE0kjSRNJE2kSaRJpImUiRtJE0iTSJNIk0iTSJNIk0iSSJJIkmSSCJJJkmSJJJGkiaRJpI2kSaRJpImUiRtJE0iTSJNIk0iTSJNIk0iTSJJIkkmSSJJlCRJJI0kTaRNJE2kSaRJFEmbRJpEmkSaRJpEmkSaRJpEkkSSJJJEkiRJkiTa') format('woff2');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        .font-title { 
            font-family: 'Cinzel', 'Book Antiqua', 'Palatino Linotype', 'Palatino', 'Times New Roman', serif; 
            font-weight: normal; 
            text-transform: uppercase; 
            letter-spacing: 0.2em; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            font-variant: small-caps;
        }
        .text-xs { font-size: 0.75rem; line-height: 1rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
        .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
        .text-5xl { font-size: 3rem; line-height: 1; }
        .text-6xl { font-size: 3.75rem; line-height: 1; }
        .text-7xl { font-size: 4.5rem; line-height: 1; }
        .font-bold { font-weight: 700; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }
        
        /* Colors */
        .text-gray-300 { color: #d1d5db; }
        .text-gray-400 { color: #9ca3af; }
        .text-gray-500 { color: #6b7280; }
        .text-blue-400 { color: #60a5fa; }
        .text-yellow-400 { color: #facc15; }
        .text-red-400 { color: #f87171; }
        .text-green-400 { color: #4ade80; }
        .text-purple-400 { color: #c084fc; }
        .text-red-700 { color: #b91c1c; }
        .bg-green-700 { background-color: #15803d; }
        .bg-blue-700 { background-color: #1d4ed8; }
        .tracking-wider { letter-spacing: 0.05em; }
        .bg-gray-600 { background-color: #4b5563; }
        .bg-gray-700 { background-color: #374151; }
        .bg-gray-800 { background-color: #1f2937; }
        .bg-red-600 { background-color: #dc2626; }
        .bg-red-700 { background-color: #b91c1c; }
        .bg-green-600 { background-color: #059669; }
        .bg-blue-600 { background-color: #2563eb; }
        .bg-black { background-color: #000000; }
        .border-gray-700 { border-color: #374151; }
        .border-red-700 { border-color: #b91c1c; }
        
        /* Layout */
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .flex-1 { flex: 1 1 0%; }
        .flex-wrap { flex-wrap: wrap; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .justify-end { justify-content: flex-end; }
        .items-center { align-items: center; }
        .grid { display: grid; }
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        .grid-cols-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
        .col-span-2 { grid-column: span 2 / span 2; }
        .rounded-t-lg { border-top-left-radius: 0.5rem; border-top-right-radius: 0.5rem; }
        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .gap-4 { gap: 1rem; }
        .gap-6 { gap: 1.5rem; }
        
        /* Spacing */
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .p-8 { padding: 2rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .m-0 { margin: 0; }
        .mx-auto { margin-left: auto; margin-right: auto; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-4 { margin-top: 1rem; }
        .mt-6 { margin-top: 1.5rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .ml-4 { margin-left: 1rem; }
        .space-x-2 > * + * { margin-left: 0.5rem; }
        .space-y-2 > * + * { margin-top: 0.5rem; }
        .space-y-3 > * + * { margin-top: 0.75rem; }
        .space-y-4 > * + * { margin-top: 1rem; }
        
        /* Sizing */
        .w-full { width: 100%; }
        .h-64 { height: 16rem; }
        .h-full { height: 100%; }
        .max-w-2xl { max-width: 42rem; }
        .max-w-xs { max-width: 20rem; }
        .max-h-96 { max-height: 24rem; }
        .min-h-screen { min-height: 100vh; }
        
        /* Borders */
        .border { border-width: 1px; }
        .border-b { border-bottom-width: 1px; }
        .border-b-2 { border-bottom-width: 2px; }
        .border-l-4 { border-left-width: 4px; }
        .rounded { border-radius: 0.25rem; }
        .rounded-md { border-radius: 0.375rem; }
        .rounded-lg { border-radius: 0.5rem; }
        
        /* Interactive */
        .cursor-pointer { cursor: pointer; }
        .transition { transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter; transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1); transition-duration: 150ms; }
        .hover\\:bg-gray-600:hover { background-color: #4b5563; }
        .hover\\:border-red-700:hover { border-color: #b91c1c; }
        .hover\\:text-red-300:hover { color: #fca5a5; }
        
        /* Visibility */
        .hidden { display: none !important; }
        .block { display: block; }
        .inline-block { display: inline-block; }
        .overflow-y-auto { overflow-y: auto; }
        .overflow-hidden { overflow: hidden; }
        
        /* Position */
        .fixed { position: fixed; }
        .absolute { position: absolute; }
        .relative { position: relative; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .top-1 { top: 0.25rem; }
        .right-1 { right: 0.25rem; }
        .z-50 { z-index: 50; }
        .z-1000 { z-index: 1000; }
        
        /* Components */
        .card {
            background: 
                radial-gradient(circle at top left, rgba(139, 69, 19, 0.15) 0%, transparent 50%),
                linear-gradient(145deg, #8b4513 0%, #a0522d 15%, #d2691e 30%, #cd853f 50%, #a0522d 70%, #8b4513 100%);
            border: 3px solid #654321;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 
                inset 0 2px 4px rgba(255, 248, 220, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.4),
                0 8px 32px rgba(0, 0, 0, 0.6);
            transition: all 0.3s;
            position: relative;
            color: #2f1b14;
            text-shadow: 1px 1px 2px rgba(255, 248, 220, 0.8);
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 1px, rgba(139, 69, 19, 0.1) 2px),
                repeating-linear-gradient(-45deg, transparent, transparent 1px, rgba(160, 82, 45, 0.05) 2px);
            border-radius: 12px;
            pointer-events: none;
            opacity: 0.6;
        }
        
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 
                inset 0 2px 4px rgba(255, 248, 220, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3),
                0 12px 40px rgba(0, 0, 0, 0.7);
            border-color: #8b4513;
        }
        
        .btn {
            background: 
                radial-gradient(circle at top, rgba(255, 248, 220, 0.2) 0%, transparent 60%),
                linear-gradient(145deg, #8b4513 0%, #cd853f 25%, #daa520 50%, #cd853f 75%, #8b4513 100%);
            color: #2f1b14;
            border: 2px solid #654321;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: all 0.3s;
            display: inline-block;
            text-decoration: none;
            text-shadow: 1px 1px 2px rgba(255, 248, 220, 0.8);
            box-shadow: 
                inset 0 1px 2px rgba(255, 248, 220, 0.4),
                inset 0 -1px 2px rgba(0, 0, 0, 0.3),
                0 3px 8px rgba(0, 0, 0, 0.4);
            position: relative;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg, 
                transparent, 
                transparent 1px, 
                rgba(139, 69, 19, 0.1) 2px
            );
            border-radius: 6px;
            pointer-events: none;
        }
        
        .btn:hover {
            background: 
                radial-gradient(circle at top, rgba(255, 248, 220, 0.3) 0%, transparent 60%),
                linear-gradient(145deg, #a0522d 0%, #daa520 25%, #ffd700 50%, #daa520 75%, #a0522d 100%);
            transform: translateY(-2px);
            box-shadow: 
                inset 0 1px 2px rgba(255, 248, 220, 0.5),
                inset 0 -1px 2px rgba(0, 0, 0, 0.2),
                0 6px 12px rgba(0, 0, 0, 0.5);
            border-color: #8b4513;
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: linear-gradient(145deg, #6d4c28 0%, #8b6914 100%);
            color: #5a4a3a;
        }
        
        .input-field {
            background: #374151;
            border: 1px solid #6b7280;
            color: #e5e7eb;
            padding: 0.5rem;
            border-radius: 0.375rem;
            width: 100%;
        }
        .input-field:focus {
            outline: none;
            border-color: #dc2626;
            box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.2);
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .tab-btn {
            background: linear-gradient(145deg, #374151, #4b5563);
            border: 2px solid #6b7280;
            color: #e5e7eb;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        .tab-btn:hover {
            background: linear-gradient(145deg, #4b5563, #6b7280);
            transform: translateY(-2px);
        }
        .tab-btn.active {
            background: linear-gradient(145deg, #dc2626, #ef4444);
            border-color: #f87171;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        }
        
        .tab-content {
            display: none;
            background: linear-gradient(145deg, #1f2937, #374151);
            border: 2px solid #4b5563;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .tab-content.active {
            display: block;
        }
        
        /* Responsive Classes */
        @media (min-width: 768px) {
            .md\\:p-8 { padding: 2rem; }
            .md\\:text-7xl { font-size: 4.5rem; line-height: 1; }
        }
        
        @media (min-width: 1024px) {
            .lg\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .lg\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .lg\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
            .lg\\:col-span-2 { grid-column: span 2 / span 2; }
        }
        
        /* Additional spacing and layout classes */
        .gap-8 { gap: 2rem; }
        .space-y-6 > * + * { margin-top: 1.5rem; }
        .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
        .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
        
        /* Additional responsive classes */
        @media (min-width: 768px) {
            .md\\:mt-6 { margin-top: 1.5rem; }
        }
        
        /* Additional margin and padding classes */
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .pb-2 { padding-bottom: 0.5rem; }
        .mb-8 { margin-bottom: 2rem; }
        
        /* Height and max-height classes */
        .h-6 { height: 1.5rem; }
        .h-16 { height: 4rem; }
        .h-32 { height: 8rem; }
        .h-96 { height: 24rem; }
        .w-16 { width: 4rem; }
        .max-h-48 { max-height: 12rem; }
        .max-h-64 { max-height: 16rem; }
        .max-h-96 { max-height: 24rem; }
        
        /* Border classes */
        .border-b { border-bottom-width: 1px; }
        .border-b-2 { border-bottom-width: 2px; }
        .border-gray-700 { border-color: #374151; }
        .border-red-700 { border-color: #b91c1c; }
        
        /* Flexbox utilities */
        .flex-wrap { flex-wrap: wrap; }
        .justify-center { justify-content: center; }
        
        /* Mobile-first responsive overrides */
        @media (max-width: 768px) {
            .tabs { flex-direction: column; }
            .grid-cols-2, .grid-cols-3, .grid-cols-4, .grid-cols-6 { grid-template-columns: 1fr; }
            .container { padding: 0.5rem; }
        }
        .btn-google {
            background-color: #4285F4;
            border-color: #4285F4;
        }
        .btn-google:hover {
            background-color: #5a95f5;
        }
        .output-box {
            background-color: #222;
            border: 1px solid #444;
            min-height: 150px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .turn-active {
            background-color: #a52a2a !important; /* Brighter red */
            color: #fff;
            border-left: 6px solid #ff4500;
            transform: scale(1.02);
            box-shadow: 0 0 12px rgba(255, 69, 0, 0.6);
            transition: all 0.2s ease-in-out;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #8b0000;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Duplicate tab-btn rules removed - consolidated above */
        #map-board, #combat-map-board {
            position: relative;
            width: 100%;
            aspect-ratio: 1/1;
            overflow: hidden;
        }
        #map-grid, #combat-map-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: linear-gradient(rgba(255,255,255,0.2) 2px, transparent 2px), linear-gradient(90deg, rgba(255,255,255,0.2) 2px, transparent 2px);
            background-size: 5% 5%;
            pointer-events: none;
        }
        .token {
            position: absolute;
            width: 4%;
            height: 4%;
            cursor: grab;
            user-select: none;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.7));
        }
        .token svg {
            width: 100%;
            height: 100%;
        }
        .token.player svg { fill: #3b82f6; stroke: #fff; stroke-width: 2px; }
        .token.enemy svg { fill: #dc2626; stroke: #fff; stroke-width: 2px; }
        .token.dragging { cursor: grabbing; z-index: 1000; filter: drop-shadow(0 5px 15px rgba(0,0,0,0.9));}
        .modal-backdrop {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            z-index: 50;
            display: flex; /* Changed for easier centering */
        }
        .dice-bowl {
            background-color: #1a1a1a;
            border: 2px dashed #444;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f3f3f3;
        }
        .dice-btn {
            background-color: #383838;
        }
        .dice-btn:hover {
            background-color: #555;
        }
        #tokenTooltip {
            position: fixed;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 2000;
            transition: opacity 0.2s;
        }
        .library-item {
            border: 1px solid #444;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .library-item:hover {
            border-color: #a52a2a;
        }
        .folder-item {
            background-color: #383838;
        }
        .breadcrumb-link {
            cursor: pointer;
            text-decoration: underline;
        }
        .creator-step {
            display: none;
        }
        .creator-step.active {
            display: block;
        }
        .checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 0.5rem;
        }
        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .creature-card {
            border: 2px solid #444;
            transition: all 0.3s ease;
        }
        .creature-card.active {
            border-color: #ff4500;
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.5);
        }
        .hp-bar {
            background: linear-gradient(90deg, #10b981 0%, #f59e0b 70%, #ef4444 100%);
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .combat-action-btn {
            background: #8b0000;
            transition: all 0.2s ease;
        }
        .combat-action-btn:hover {
            background: #a52a2a;
            transform: scale(1.05);
        }
        #map-canvas {
            cursor: crosshair;
        }
        .token-piece {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #fff;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .token-player { background: #3b82f6; }
        .token-enemy { background: #dc2626; }
        .token-npc { background: #10b981; }
        .ai-config {
            border: 1px dashed #444;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }
        
        /* Fullscreen Battle Map Styles */
        #battle-map.fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            z-index: 9999 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: #000 !important;
            border-radius: 0 !important;
        }
        
        #battle-map.fullscreen #map-canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        #exit-fullscreen {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: rgba(220, 38, 38, 0.9);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <!-- Basic structure will be expanded significantly -->
    <header class="text-center mb-8 relative">
        <h1 class="font-title text-5xl md:text-7xl text-red-700 tracking-wider">Dungeon Master Helper</h1>
        <p class="text-gray-400">Your comprehensive D&D 5e companion for epic adventures.</p>
    </header>

    <!-- Navigation Tabs -->
    <div class="flex flex-wrap justify-center mb-8 border-b border-gray-700">
        <button id="tab-session" class="tab-btn active font-title text-xl py-2 px-6 rounded-t-lg">Session</button>
        <button id="tab-combat" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Combat</button>
        <button id="tab-characters" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Characters</button>
        <button id="tab-spells" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Spells</button>
        <button id="tab-monsters" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Monsters</button>
        <button id="tab-maps" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Maps</button>
        <button id="tab-dice" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Dice</button>
        <button id="tab-tools" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">Tools</button>
        <button id="tab-ai" class="tab-btn font-title text-xl py-2 px-6 rounded-t-lg">AI Assistant</button>
    </div>

    <main>
        <!-- Session Management Tab -->
        <div id="content-session" class="tab-content active">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div class="lg:col-span-2 space-y-6">
                    <!-- Current Party -->
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Current Party</h2>
                        <div id="party-display" class="space-y-4"></div>
                        <button id="manage-party-btn" class="btn font-title w-full py-2 rounded-md mt-4">👥 Manage Party</button>
                    </section>
                    
                    <!-- Session Notes -->
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Session Notes</h2>
                        <textarea id="session-notes" class="input-field w-full p-4 h-32 rounded-md" placeholder="Write your session notes here..."></textarea>
                        <div class="flex gap-2 mt-4">
                            <button id="save-notes-btn" class="btn font-title py-2 px-4 rounded-md">💾 Save Notes</button>
                            <button id="auto-note-btn" class="btn font-title py-2 px-4 rounded-md">🤖 AI Summary</button>
                        </div>
                    </section>
                </div>
                
                <div class="space-y-6">
                    <!-- Quick Actions -->
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Quick Actions</h2>
                        <div class="space-y-3">
                            <button id="random-encounter-btn" class="btn font-title w-full py-2 rounded-md">⚔️ Random Encounter</button>
                            <button id="quick-npc-btn" class="btn font-title w-full py-2 rounded-md">🧙 Generate NPC</button>
                            <button id="environment-btn" class="btn font-title w-full py-2 rounded-md">🌲 Environment Details</button>
                            <button id="plot-hook-btn" class="btn font-title w-full py-2 rounded-md">📜 Plot Hook</button>
                        </div>
                    </section>
                    
                    <!-- Time & Environment -->
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Time & Environment</h2>
                        <div class="space-y-4">
                            <div>
                                <label class="font-bold block mb-1">Day:</label>
                                <input type="number" id="current-day" class="input-field w-full p-2" value="1" min="1">
                            </div>
                            <div>
                                <label class="font-bold block mb-1">Time:</label>
                                <input type="time" id="current-time" class="input-field w-full p-2" value="08:00">
                            </div>
                            <div>
                                <label class="font-bold block mb-1">Weather:</label>
                                <select id="weather-select" class="input-field w-full p-2">
                                    <option value="Clear">Clear</option>
                                    <option value="Cloudy">Cloudy</option>
                                    <option value="Rainy">Rainy</option>
                                    <option value="Stormy">Stormy</option>
                                    <option value="Foggy">Foggy</option>
                                    <option value="Snowy">Snowy</option>
                                </select>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>

        <!-- Combat Tab -->
        <div id="content-combat" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <!-- Combat Map -->
                <div class="lg:col-span-2">
                    <section class="card p-6">
                        <div class="flex justify-between items-center border-b-2 border-red-700 pb-2 mb-4">
                            <h2 class="font-title text-3xl">Battle Map</h2>
                            <div class="flex gap-2">
                                <button id="toggle-grid" class="btn text-sm py-1 px-3 rounded-md">⚏ Grid</button>
                                <button id="add-token" class="btn text-sm py-1 px-3 rounded-md">🪙 Add Token</button>
                                <button id="fullscreen-map" class="btn text-sm py-1 px-3 rounded-md bg-blue-600">🔳 Fullscreen</button>
                                <button id="clear-map" class="btn text-sm py-1 px-3 rounded-md bg-red-700">🗑️ Clear</button>
                            </div>
                        </div>
                        <div id="battle-map" class="bg-black rounded-md h-96 relative overflow-hidden">
                            <canvas id="map-canvas" class="w-full h-full"></canvas>
                            <div id="map-tokens"></div>
                            <button id="exit-fullscreen" class="hidden btn text-sm py-2 px-4 rounded-md bg-red-600">✕ Exit Fullscreen</button>
                        </div>
                    </section>
                </div>
                
                <!-- Initiative Tracker -->
                <div>
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Initiative</h2>
                        <div id="initiative-list" class="space-y-2 max-h-64 overflow-y-auto"></div>
                        <div class="flex gap-2 mt-4">
                            <button id="roll-initiative" class="btn font-title flex-1 py-2 rounded-md">🎲 Roll Initiative</button>
                            <button id="next-turn" class="btn font-title flex-1 py-2 rounded-md">Next Turn</button>
                        </div>
                        <div class="mt-4">
                            <p class="text-sm text-gray-400">Round: <span id="round-counter">0</span></p>
                            <p class="text-sm text-gray-400">Turn: <span id="turn-counter">0</span></p>
                        </div>
                    </section>
                </div>
                
                <!-- Active Creature -->
                <div>
                    <section class="card p-6">
                        <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Active Creature</h2>
                        <div id="active-creature-info">
                            <p class="text-gray-400">No active creature</p>
                        </div>
                        <div class="mt-4 space-y-2">
                            <button id="auto-attack" class="btn font-title w-full py-2 rounded-md">Auto Attack</button>
                            <button id="cast-spell" class="btn font-title w-full py-2 rounded-md">Cast Spell</button>
                            <button id="take-damage" class="btn font-title w-full py-2 rounded-md bg-red-700">Take Damage</button>
                            <button id="heal-creature" class="btn font-title w-full py-2 rounded-md bg-green-700">Heal</button>
                        </div>
                    </section>
                </div>
            </div>
            
            <!-- Combat Settings -->
            <section class="card p-6 mt-6">
                <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">⚙️ Combat Rules</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="space-y-3">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="setting-advanced-diagonals" class="w-4 h-4">
                            <span class="text-sm">Advanced Diagonal Movement (5/10ft pattern)</span>
                        </label>
                        <p class="text-xs text-gray-400 ml-6">When enabled, diagonals alternate between 5ft and 10ft cost. Default: all diagonals cost 5ft.</p>
                    </div>
                    <div class="space-y-3">
                        <label class="flex items-center gap-2">
                            <input type="checkbox" id="setting-critical-death-saves" class="w-4 h-4" checked>
                            <span class="text-sm">Critical Hit Rules for Death Saves</span>
                        </label>
                        <p class="text-xs text-gray-400 ml-6">Attacks from within 5ft on unconscious creatures cause 2 death save failures.</p>
                    </div>
                </div>
            </section>

            <!-- Combat Log -->
            <section class="card p-6 mt-6">
                <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Combat Log</h2>
                <div id="combat-log" class="output-box p-4 h-32 overflow-y-auto"></div>
            </section>
        </div>

        <!-- Character Management Tab -->
        <div id="content-characters" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Character Creator</h2>
                    <div class="space-y-4">
                        <button id="new-character-btn" class="btn font-title w-full py-3 rounded-md">Create New Character</button>
                        <button id="import-character-btn" class="btn font-title w-full py-3 rounded-md bg-blue-700">Import Character</button>
                        <button id="random-character-btn" class="btn font-title w-full py-3 rounded-md bg-green-700">Random Character</button>
                    </div>
                </section>
                
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Character Library</h2>
                    <div id="character-list" class="space-y-2 max-h-96 overflow-y-auto"></div>
                </section>
            </div>
        </div>
        
        <!-- Spell Database Tab -->
        <div id="content-spells" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Spell Search</h2>
                    <div class="space-y-4">
                        <input type="text" id="spell-search" class="input-field w-full p-2" placeholder="Search spells...">
                        <select id="spell-level-filter" class="input-field w-full p-2">
                            <option value="">All Levels</option>
                            <option value="0">Cantrips</option>
                            <option value="1">1st Level</option>
                            <option value="2">2nd Level</option>
                            <option value="3">3rd Level</option>
                            <option value="4">4th Level</option>
                            <option value="5">5th Level</option>
                            <option value="6">6th Level</option>
                            <option value="7">7th Level</option>
                            <option value="8">8th Level</option>
                            <option value="9">9th Level</option>
                        </select>
                        <select id="spell-class-filter" class="input-field w-full p-2">
                            <option value="">All Classes</option>
                            <option value="Bard">Bard</option>
                            <option value="Cleric">Cleric</option>
                            <option value="Druid">Druid</option>
                            <option value="Paladin">Paladin</option>
                            <option value="Ranger">Ranger</option>
                            <option value="Sorcerer">Sorcerer</option>
                            <option value="Warlock">Warlock</option>
                            <option value="Wizard">Wizard</option>
                        </select>
                    </div>
                </section>
                
                <section class="card p-6 lg:col-span-2">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Spell Details</h2>
                    <div id="spell-details" class="text-gray-400">Select a spell to view details</div>
                </section>
            </div>
            
            <section class="card p-6 mt-6">
                <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Spell List</h2>
                <div id="spell-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
            </section>
        </div>
        
        <!-- Monster Compendium Tab -->
        <div id="content-monsters" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Monster Search</h2>
                    <div class="space-y-4">
                        <input type="text" id="monster-search" class="input-field w-full p-2" placeholder="Search monsters...">
                        <select id="monster-cr-filter" class="input-field w-full p-2">
                            <option value="">All Challenge Ratings</option>
                            <option value="0">CR 0</option>
                            <option value="1/8">CR 1/8</option>
                            <option value="1/4">CR 1/4</option>
                            <option value="1/2">CR 1/2</option>
                            <option value="1">CR 1</option>
                            <option value="2">CR 2</option>
                            <option value="3">CR 3</option>
                            <option value="4">CR 4</option>
                            <option value="5">CR 5</option>
                            <option value="10">CR 10+</option>
                        </select>
                        <select id="monster-type-filter" class="input-field w-full p-2">
                            <option value="">All Types</option>
                            <option value="beast">Beast</option>
                            <option value="humanoid">Humanoid</option>
                            <option value="giant">Giant</option>
                            <option value="dragon">Dragon</option>
                            <option value="undead">Undead</option>
                            <option value="fiend">Fiend</option>
                            <option value="celestial">Celestial</option>
                        </select>
                        <button id="add-to-encounter-btn" class="btn font-title w-full py-2 rounded-md">Add to Encounter</button>
                    </div>
                </section>
                
                <section class="card p-6 lg:col-span-2">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Monster Details</h2>
                    <div id="monster-details" class="text-gray-400">Select a monster to view stat block</div>
                </section>
            </div>
            
            <section class="card p-6 mt-6">
                <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Monster List</h2>
                <div id="monster-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
            </section>
        </div>
        
        <!-- Map System Tab -->
        <div id="content-maps" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Map Library</h2>
                    <div class="space-y-4">
                        <button id="upload-map-btn" class="btn font-title w-full py-2 rounded-md">Upload Map</button>
                        <button id="generate-map-btn" class="btn font-title w-full py-2 rounded-md bg-green-700">Generate Map</button>
                        <input type="text" id="map-search" class="input-field w-full p-2" placeholder="Search maps...">
                    </div>
                    <div id="map-library" class="space-y-2 max-h-96 overflow-y-auto mt-4"></div>
                </section>
                
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Map Viewer</h2>
                    <div id="map-viewer" class="bg-black rounded-md h-96 relative overflow-hidden">
                        <p class="text-gray-400 text-center pt-44">No map selected</p>
                    </div>
                </section>
            </div>
        </div>
        
        <!-- Dice Roller Tab -->
        <div id="content-dice" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Dice Roller</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-3 gap-2">
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="4">d4</button>
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="6">d6</button>
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="8">d8</button>
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="10">d10</button>
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="12">d12</button>
                            <button class="dice-btn btn py-8 rounded-md font-title text-2xl" data-sides="20">d20</button>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button class="dice-btn btn py-4 rounded-md font-title" data-sides="100">d100</button>
                            <button id="custom-dice" class="btn py-4 rounded-md font-title">Custom</button>
                        </div>
                        <div class="space-y-2">
                            <input type="text" id="dice-formula" class="input-field w-full p-2" placeholder="e.g., 2d6+3, 1d20+5">
                            <div class="grid grid-cols-2 gap-2">
                                <button id="roll-advantage" class="btn py-2 rounded-md">Advantage</button>
                                <button id="roll-disadvantage" class="btn py-2 rounded-md">Disadvantage</button>
                            </div>
                        </div>
                    </div>
                </section>
                
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Roll Results</h2>
                    <div id="dice-results" class="output-box p-4 h-96 overflow-y-auto"></div>
                    <button id="clear-results" class="btn font-title w-full py-2 rounded-md mt-4">Clear Results</button>
                </section>
            </div>
        </div>
        
        <!-- DM Tools Tab -->
        <div id="content-tools" class="tab-content">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Encounter Builder</h2>
                    <div class="space-y-4">
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label class="font-bold block mb-1">Party Level:</label>
                                <input type="number" id="party-level" class="input-field w-full p-2" value="1" min="1" max="20">
                            </div>
                            <div>
                                <label class="font-bold block mb-1">Party Size:</label>
                                <input type="number" id="party-size" class="input-field w-full p-2" value="4" min="1" max="8">
                            </div>
                        </div>
                        <select id="encounter-difficulty" class="input-field w-full p-2">
                            <option value="easy">Easy</option>
                            <option value="medium">Medium</option>
                            <option value="hard">Hard</option>
                            <option value="deadly">Deadly</option>
                        </select>
                        <button id="build-encounter" class="btn font-title w-full py-2 rounded-md">Build Encounter</button>
                    </div>
                    <div id="encounter-results" class="mt-4 p-4 bg-gray-800 rounded-md"></div>
                </section>
                
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Random Generators</h2>
                    <div class="space-y-3">
                        <button id="gen-treasure" class="btn font-title w-full py-2 rounded-md">Generate Treasure</button>
                        <button id="gen-trap" class="btn font-title w-full py-2 rounded-md">Generate Trap</button>
                        <button id="gen-puzzle" class="btn font-title w-full py-2 rounded-md">Generate Puzzle</button>
                        <button id="gen-weather" class="btn font-title w-full py-2 rounded-md">Random Weather</button>
                        <button id="gen-rumor" class="btn font-title w-full py-2 rounded-md">Generate Rumor</button>
                        <button id="gen-tavern" class="btn font-title w-full py-2 rounded-md">Generate Tavern</button>
                    </div>
                    <div id="generator-output" class="output-box mt-4 p-4 h-48 overflow-y-auto"></div>
                </section>
            </div>
        </div>
        
        <!-- AI Assistant Tab -->
        <div id="content-ai" class="tab-content">
            <div class="ai-config">
                <h3 class="font-title text-2xl mb-4">🤖 Gemini AI Assistant</h3>
                <p class="text-gray-400 mb-4">✅ Gemini API securely configured! Ready for AI-powered DM assistance including NPC generation, descriptions, and campaign help.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="font-bold block mb-1">Status:</label>
                        <div id="ai-status" class="text-green-400 font-bold">🟢 Ready</div>
                    </div>
                    <div>
                        <label class="font-bold block mb-1">Model:</label>
                        <select id="ai-model" class="input-field w-full p-2">
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                        </select>
                    </div>
                </div>
                <button id="test-ai" class="btn font-title py-2 px-4 rounded-md">Test AI Connection</button>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">AI Chat</h2>
                    <div id="ai-chat" class="output-box p-4 h-64 overflow-y-auto mb-4"></div>
                    <div class="flex gap-2">
                        <input type="text" id="ai-input" class="input-field flex-1 p-2" placeholder="Ask the AI assistant...">
                        <button id="send-ai" class="btn font-title py-2 px-4 rounded-md">Send</button>
                    </div>
                </section>
                
                <section class="card p-6">
                    <h2 class="font-title text-3xl border-b-2 border-red-700 pb-2 mb-4">Quick AI Tools</h2>
                    <div class="space-y-3">
                        <button id="ai-npc" class="btn font-title w-full py-2 rounded-md">Generate NPC</button>
                        <button id="ai-description" class="btn font-title w-full py-2 rounded-md">Generate Description</button>
                        <button id="ai-plot" class="btn font-title w-full py-2 rounded-md">Generate Plot Hook</button>
                        <button id="ai-dialogue" class="btn font-title w-full py-2 rounded-md">Generate Dialogue</button>
                        <button id="ai-riddle" class="btn font-title w-full py-2 rounded-md">Generate Riddle</button>
                        <button id="ai-lore" class="btn font-title w-full py-2 rounded-md">Generate Lore</button>
                    </div>
                </section>
            </div>
        </div>
    </main>

    <script>
        console.log('🐉 D&D Dungeon Master Helper - Ultimate Edition Loading... 🐉');
        
        // ===== COMPREHENSIVE D&D 5E DATABASE =====
        // Complete embedded database with all official content
        const DND_DATA = {
            // Character Races Database
            races: {
                "Human": {
                    description: "Versatile and adaptable, humans are the most common race in most worlds.",
                    abilityScoreIncrease: {"all": 1},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "One extra language"],
                    traits: ["Extra Skill", "Extra Feat (Variant)"],
                    subraces: [
                        {name: "Standard Human", features: ["Versatile"]},
                        {name: "Variant Human", features: ["Extra Skill", "Extra Feat"]}
                    ]
                },
                "Elf": {
                    description: "Magical people of otherworldly grace, living in harmony with the natural and magical world.",
                    abilityScoreIncrease: {"Dexterity": 2},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "Elvish"],
                    traits: ["Darkvision", "Keen Senses", "Fey Ancestry", "Trance"],
                    subraces: [
                        {name: "High Elf", abilityIncrease: {"Intelligence": 1}, features: ["Elf Weapon Training", "Cantrip"]},
                        {name: "Wood Elf", abilityIncrease: {"Wisdom": 1}, features: ["Elf Weapon Training", "Fleet of Foot", "Mask of the Wild"]},
                        {name: "Dark Elf (Drow)", abilityIncrease: {"Charisma": 1}, features: ["Superior Darkvision", "Sunlight Sensitivity", "Drow Magic"]}
                    ]
                },
                "Dwarf": {
                    description: "Bold and hardy, dwarves are known as skilled warriors, miners, and workers of stone and metal.",
                    abilityScoreIncrease: {"Constitution": 2},
                    size: "Medium",
                    speed: 25,
                    languages: ["Common", "Dwarvish"],
                    traits: ["Darkvision", "Dwarven Resilience", "Dwarven Combat Training", "Stonecunning"],
                    subraces: [
                        {name: "Hill Dwarf", abilityIncrease: {"Wisdom": 1}, features: ["Dwarven Toughness"]},
                        {name: "Mountain Dwarf", abilityIncrease: {"Strength": 2}, features: ["Armor Proficiency"]}
                    ]
                },
                "Halfling": {
                    description: "The diminutive halflings survive in a world full of larger creatures by avoiding notice or, barring that, avoiding offense.",
                    abilityScoreIncrease: {"Dexterity": 2},
                    size: "Small",
                    speed: 25,
                    languages: ["Common", "Halfling"],
                    traits: ["Lucky", "Brave", "Halfling Nimbleness"],
                    subraces: [
                        {name: "Lightfoot", abilityIncrease: {"Charisma": 1}, features: ["Naturally Stealthy"]},
                        {name: "Stout", abilityIncrease: {"Constitution": 1}, features: ["Stout Resilience"]}
                    ]
                },
                "Dragonborn": {
                    description: "Born of dragons, as their name proclaims, the dragonborn walk proudly through a world that greets them with fearful incomprehension.",
                    abilityScoreIncrease: {"Strength": 2, "Charisma": 1},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "Draconic"],
                    traits: ["Draconic Ancestry", "Breath Weapon", "Damage Resistance"],
                    subraces: [
                        {name: "Red", features: ["Fire Breath", "Fire Resistance"]},
                        {name: "Blue", features: ["Lightning Breath", "Lightning Resistance"]},
                        {name: "Green", features: ["Poison Breath", "Poison Resistance"]},
                        {name: "Black", features: ["Acid Breath", "Acid Resistance"]},
                        {name: "White", features: ["Cold Breath", "Cold Resistance"]}
                    ]
                },
                "Gnome": {
                    description: "A constant hum of busy activity pervades the warrens and neighborhoods where gnomes form their close-knit communities.",
                    abilityScoreIncrease: {"Intelligence": 2},
                    size: "Small",
                    speed: 25,
                    languages: ["Common", "Gnomish"],
                    traits: ["Darkvision", "Gnome Cunning"],
                    subraces: [
                        {name: "Forest Gnome", abilityIncrease: {"Dexterity": 1}, features: ["Natural Illusionist", "Speak with Small Beasts"]},
                        {name: "Rock Gnome", abilityIncrease: {"Constitution": 1}, features: ["Artificer's Lore", "Tinker"]}
                    ]
                },
                "Half-Elf": {
                    description: "Walking in two worlds but truly belonging to neither, half-elves combine what some say are the best qualities of their elf and human parents.",
                    abilityScoreIncrease: {"Charisma": 2, "two_different": 1},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "Elvish", "One extra language"],
                    traits: ["Darkvision", "Fey Ancestry", "Two Skills"],
                    subraces: []
                },
                "Half-Orc": {
                    description: "Whether united under the leadership of a mighty warlock or having fought to a standstill after years of conflict, orc and human communities sometimes form alliances.",
                    abilityScoreIncrease: {"Strength": 2, "Constitution": 1},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "Orc"],
                    traits: ["Darkvision", "Relentless Endurance", "Savage Attacks"],
                    subraces: []
                },
                "Tiefling": {
                    description: "To be greeted with stares and whispers, to suffer violence and insult on the street, to see mistrust and fear in every eye: this is the lot of the tiefling.",
                    abilityScoreIncrease: {"Intelligence": 1, "Charisma": 2},
                    size: "Medium",
                    speed: 30,
                    languages: ["Common", "Infernal"],
                    traits: ["Darkvision", "Hellish Resistance", "Infernal Legacy"],
                    subraces: []
                }
            },
            
            // Character Classes Database
            classes: {
                "Fighter": {
                    description: "A master of martial combat, skilled with a variety of weapons and armor.",
                    hitDie: 10,
                    primaryAbility: ["Strength", "Dexterity"],
                    savingThrows: ["Strength", "Constitution"],
                    proficiencies: {
                        armor: ["All armor", "shields"],
                        weapons: ["Simple weapons", "martial weapons"],
                        tools: [],
                        skills: {
                            count: 2,
                            options: ["Acrobatics", "Animal Handling", "Athletics", "History", "Insight", "Intimidation", "Perception", "Survival"]
                        }
                    },
                    equipment: [
                        "Chain mail",
                        "Shield",
                        "Martial weapon",
                        "Light crossbow and 20 bolts",
                        "Dungeoneer's pack"
                    ],
                    features: {
                        level1: ["Fighting Style", "Second Wind"],
                        level2: ["Action Surge"],
                        level3: ["Martial Archetype"]
                    },
                    subclasses: ["Champion", "Battle Master", "Eldritch Knight"]
                },
                "Wizard": {
                    description: "A scholarly magic-user capable of manipulating the structures of reality.",
                    hitDie: 6,
                    primaryAbility: ["Intelligence"],
                    savingThrows: ["Intelligence", "Wisdom"],
                    proficiencies: {
                        armor: [],
                        weapons: ["Daggers", "darts", "slings", "quarterstaffs", "light crossbows"],
                        tools: [],
                        skills: {
                            count: 2,
                            options: ["Arcana", "History", "Insight", "Investigation", "Medicine", "Religion"]
                        }
                    },
                    equipment: [
                        "Quarterstaff or dagger",
                        "Component pouch or arcane focus",
                        "Scholar's pack",
                        "Spellbook"
                    ],
                    features: {
                        level1: ["Spellcasting", "Arcane Recovery"],
                        level2: ["Arcane Tradition"]
                    },
                    subclasses: ["School of Evocation", "School of Abjuration", "School of Conjuration"]
                },
                "Rogue": {
                    description: "Rogues rely on skill, stealth, and their foes' vulnerabilities to get the upper hand in any situation.",
                    hitDie: 8,
                    primaryAbility: ["Dexterity"],
                    savingThrows: ["Dexterity", "Intelligence"],
                    proficiencies: {
                        armor: ["Light armor"],
                        weapons: ["Simple weapons", "hand crossbows", "longswords", "rapiers", "shortswords"],
                        tools: ["Thieves' tools"],
                        skills: {
                            count: 4,
                            options: ["Acrobatics", "Athletics", "Deception", "Insight", "Intimidation", "Investigation", "Perception", "Performance", "Persuasion", "Sleight of Hand", "Stealth"]
                        }
                    },
                    equipment: [
                        "Rapier or shortsword",
                        "Shortbow and quiver of 20 arrows",
                        "Burglar's pack",
                        "Leather armor",
                        "Two daggers",
                        "Thieves' tools"
                    ],
                    features: {
                        level1: ["Expertise", "Sneak Attack", "Thieves' Cant"],
                        level2: ["Cunning Action"],
                        level3: ["Roguish Archetype"]
                    },
                    subclasses: ["Thief", "Assassin", "Arcane Trickster"]
                },
                "Cleric": {
                    description: "A priestly champion who wields divine magic in service of a higher power.",
                    hitDie: 8,
                    primaryAbility: ["Wisdom"],
                    savingThrows: ["Wisdom", "Charisma"],
                    proficiencies: {
                        armor: ["Light armor", "medium armor", "shields"],
                        weapons: ["Simple weapons"],
                        tools: [],
                        skills: {
                            count: 2,
                            options: ["History", "Insight", "Medicine", "Persuasion", "Religion"]
                        }
                    },
                    equipment: [
                        "Mace or warhammer",
                        "Scale mail or leather armor",
                        "Light crossbow and 20 bolts or any simple weapon",
                        "Priest's pack",
                        "Shield",
                        "Holy symbol"
                    ],
                    features: {
                        level1: ["Spellcasting", "Divine Domain"],
                        level2: ["Channel Divinity", "Divine Domain Feature"]
                    },
                    subclasses: ["Life Domain", "Light Domain", "Knowledge Domain", "Nature Domain", "Tempest Domain", "Trickery Domain", "War Domain"]
                },
                "Ranger": {
                    description: "A warrior of the wilderness, skilled in tracking, survival, and combat.",
                    hitDie: 10,
                    primaryAbility: ["Dexterity", "Wisdom"],
                    savingThrows: ["Strength", "Dexterity"],
                    proficiencies: {
                        armor: ["Light armor", "medium armor", "shields"],
                        weapons: ["Simple weapons", "martial weapons"],
                        tools: [],
                        skills: {
                            count: 3,
                            options: ["Animal Handling", "Athletics", "Insight", "Investigation", "Nature", "Perception", "Stealth", "Survival"]
                        }
                    },
                    equipment: [
                        "Scale mail or leather armor",
                        "Two shortswords or two simple melee weapons",
                        "Dungeoneer's pack or explorer's pack",
                        "Longbow and quiver of 20 arrows"
                    ],
                    features: {
                        level1: ["Favored Enemy", "Natural Explorer"],
                        level2: ["Fighting Style", "Spellcasting"],
                        level3: ["Ranger Archetype", "Primeval Awareness"]
                    },
                    subclasses: ["Hunter", "Beast Master"]
                },
                "Paladin": {
                    description: "A holy warrior bound to a sacred oath, wielding divine magic and martial prowess.",
                    hitDie: 10,
                    primaryAbility: ["Strength", "Charisma"],
                    savingThrows: ["Wisdom", "Charisma"],
                    proficiencies: {
                        armor: ["All armor", "shields"],
                        weapons: ["Simple weapons", "martial weapons"],
                        tools: [],
                        skills: {
                            count: 2,
                            options: ["Athletics", "Insight", "Intimidation", "Medicine", "Persuasion", "Religion"]
                        }
                    },
                    equipment: [
                        "Chain mail",
                        "Shield",
                        "Five javelins or any simple melee weapon",
                        "Priest's pack or explorer's pack",
                        "Holy symbol"
                    ],
                    features: {
                        level1: ["Divine Sense", "Lay on Hands"],
                        level2: ["Fighting Style", "Spellcasting", "Divine Smite"],
                        level3: ["Divine Health", "Sacred Oath"]
                    },
                    subclasses: ["Oath of Devotion", "Oath of the Ancients", "Oath of Vengeance"]
                },
                "Barbarian": {
                    description: "A fierce warrior of primitive background who can enter a battle rage.",
                    hitDie: 12,
                    primaryAbility: ["Strength"],
                    savingThrows: ["Strength", "Constitution"],
                    proficiencies: {
                        armor: ["Light armor", "medium armor", "shields"],
                        weapons: ["Simple weapons", "martial weapons"],
                        tools: [],
                        skills: {
                            count: 2,
                            options: ["Animal Handling", "Athletics", "Intimidation", "Nature", "Perception", "Survival"]
                        }
                    },
                    equipment: [
                        "Greataxe or any martial melee weapon",
                        "Two handaxes or any simple weapon",
                        "Explorer's pack",
                        "Four javelins"
                    ],
                    features: {
                        level1: ["Rage", "Unarmored Defense"],
                        level2: ["Reckless Attack", "Danger Sense"],
                        level3: ["Primal Path"]
                    },
                    subclasses: ["Path of the Berserker", "Path of the Totem Warrior"]
                }
            },
            
            // Spells Database (comprehensive)
            spells: {
                cantrips: {
                    "Acid Splash": {level: 0, school: "Conjuration", castingTime: "1 action", range: "60 feet", components: "V, S", duration: "Instantaneous", description: "You hurl a bubble of acid. Choose one or two creatures within range. A creature must succeed on a Dexterity saving throw or take 1d6 acid damage.", damage: "1d6", damageType: "acid", savingThrow: "Dexterity", classes: ["Sorcerer", "Wizard"]},
                    "Blade Ward": {level: 0, school: "Abjuration", castingTime: "1 action", range: "Self", components: "V, S", duration: "1 round", description: "You extend your hand and trace a sigil of warding in the air. Until the end of your next turn, you have resistance against bludgeoning, piercing, and slashing damage dealt by weapon attacks.", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Chill Touch": {level: 0, school: "Necromancy", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "1 round", description: "You create a ghostly, skeletal hand in the space of a creature within range. Make a ranged spell attack against the creature to assail it with the chill of the grave.", damage: "1d8", damageType: "necrotic", attack: "ranged", classes: ["Sorcerer", "Warlock", "Wizard"]},
                    "Dancing Lights": {level: 0, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "You create up to four torch-sized lights within range, making them appear as torches, lanterns, or glowing orbs that hover in the air for the duration.", classes: ["Bard", "Sorcerer", "Wizard"]},
                    "Druidcraft": {level: 0, school: "Transmutation", castingTime: "1 action", range: "30 feet", components: "V, S", duration: "Instantaneous", description: "Whispering to the spirits of nature, you create one of the following effects within range: You create a tiny, harmless sensory effect that predicts what the weather will be at your location for the next 24 hours.", classes: ["Druid"]},
                    "Eldritch Blast": {level: 0, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "Instantaneous", description: "A beam of crackling energy streaks toward a creature within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 force damage.", damage: "1d10", damageType: "force", attack: "ranged", classes: ["Warlock"]},
                    "Fire Bolt": {level: 0, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "Instantaneous", description: "You hurl a mote of fire at a creature or object within range. Make a ranged spell attack against the target. On a hit, the target takes 1d10 fire damage. A flammable object hit by this spell ignites if it isn't being worn or carried.", damage: "1d10", damageType: "fire", attack: "ranged", classes: ["Sorcerer", "Wizard"]},
                    "Guidance": {level: 0, school: "Divination", castingTime: "1 action", range: "Touch", components: "V, S", duration: "Concentration, up to 1 minute", description: "You touch one willing creature. Once before the spell ends, the target can roll a d4 and add the number rolled to one ability check of its choice.", classes: ["Cleric", "Druid"]},
                    "Light": {level: 0, school: "Evocation", castingTime: "1 action", range: "Touch", components: "V, M", duration: "1 hour", description: "You touch one object that is no larger than 10 feet in any dimension. Until the spell ends, the object sheds bright light in a 20-foot radius and dim light for an additional 20 feet.", classes: ["Bard", "Cleric", "Sorcerer", "Wizard"]},
                    "Mage Hand": {level: 0, school: "Conjuration", castingTime: "1 action", range: "30 feet", components: "V, S", duration: "1 minute", description: "A spectral, floating hand appears at a point you choose within range. The hand lasts for the duration or until you dismiss it as an action. You can use your action to control the hand.", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Mending": {level: 0, school: "Transmutation", castingTime: "1 minute", range: "Touch", components: "V, S, M", duration: "Instantaneous", description: "This spell repairs a single break or tear in an object you touch, such as a broken chain link, two halves of a broken key, a torn cloak, or a leaking wineskin.", classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Wizard"]},
                    "Minor Illusion": {level: 0, school: "Illusion", castingTime: "1 action", range: "30 feet", components: "S, M", duration: "1 minute", description: "You create a sound or an image of an object within range that lasts for the duration. The illusion also ends if you dismiss it as an action or cast this spell again.", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Poison Spray": {level: 0, school: "Conjuration", castingTime: "1 action", range: "10 feet", components: "V, S", duration: "Instantaneous", description: "You extend your hand toward a creature you can see within range and project a puff of noxious gas from your palm. The creature must succeed on a Constitution saving throw or take 1d12 poison damage.", damage: "1d12", damageType: "poison", savingThrow: "Constitution", classes: ["Druid", "Sorcerer", "Warlock", "Wizard"]},
                    "Prestidigitation": {level: 0, school: "Transmutation", castingTime: "1 action", range: "10 feet", components: "V, S", duration: "Up to 1 hour", description: "This spell is a minor magical trick that novice spellcasters use for practice. You create one of the following magical effects within range.", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Sacred Flame": {level: 0, school: "Evocation", castingTime: "1 action", range: "60 feet", components: "V, S", duration: "Instantaneous", description: "Flame-like radiance descends on a creature that you can see within range. The target must succeed on a Dexterity saving throw or take 1d8 radiant damage.", damage: "1d8", damageType: "radiant", savingThrow: "Dexterity", classes: ["Cleric"]},
                    "Spare the Dying": {level: 0, school: "Necromancy", castingTime: "1 action", range: "Touch", components: "V, S", duration: "Instantaneous", description: "You touch a living creature that has 0 hit points. The creature becomes stable. This spell has no effect on undead or constructs.", classes: ["Cleric"]},
                    "Thaumaturgy": {level: 0, school: "Transmutation", castingTime: "1 action", range: "30 feet", components: "V", duration: "Up to 1 minute", description: "You manifest a minor wonder, a sign of supernatural power, within range. You create one of the following magical effects within range.", classes: ["Cleric"]},
                    "Thorn Whip": {level: 0, school: "Transmutation", castingTime: "1 action", range: "30 feet", components: "V, S, M", duration: "Instantaneous", description: "You create a long, vine-like whip covered in thorns that lashes out at your command toward a creature in range. Make a melee spell attack against the target.", damage: "1d6", damageType: "piercing", attack: "melee", classes: ["Druid"]},
                    "Toll the Dead": {level: 0, school: "Necromancy", castingTime: "1 action", range: "60 feet", components: "V, S", duration: "Instantaneous", description: "You point at one creature you can see within range, and the sound of a dolorous bell fills the air around it for a moment. The target must succeed on a Wisdom saving throw or take 1d8 necrotic damage.", damage: "1d8", damageType: "necrotic", savingThrow: "Wisdom", classes: ["Cleric", "Warlock", "Wizard"]},
                    "Vicious Mockery": {level: 0, school: "Enchantment", castingTime: "1 action", range: "60 feet", components: "V", duration: "Instantaneous", description: "You unleash a string of insults laced with subtle enchantments at a creature you can see within range. The target must succeed on a Wisdom saving throw or take 1d4 psychic damage and have disadvantage on its next attack roll.", damage: "1d4", damageType: "psychic", savingThrow: "Wisdom", classes: ["Bard"]}
                },
                level1: {
                    "Alarm": {level: 1, school: "Abjuration", castingTime: "1 minute", range: "30 feet", components: "V, S, M", duration: "8 hours", description: "You set an alarm against unwanted intrusion. Choose a door, a window, or an area within range that is no larger than a 20-foot cube.", classes: ["Ranger", "Wizard"]},
                    "Bane": {level: 1, school: "Enchantment", castingTime: "1 action", range: "30 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "Up to three creatures of your choice that you can see within range must make Charisma saving throws. Whenever a target that fails this saving throw makes an attack roll or a saving throw before the spell ends, the target must roll a d4 and subtract the number rolled from the attack roll or saving throw.", savingThrow: "Charisma", classes: ["Bard", "Cleric"]},
                    "Bless": {level: 1, school: "Enchantment", castingTime: "1 action", range: "30 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "You bless up to three creatures of your choice within range. Whenever a target makes an attack roll or a saving throw before the spell ends, the target can roll a d4 and add the number rolled to the attack roll or saving throw.", classes: ["Cleric", "Paladin"]},
                    "Burning Hands": {level: 1, school: "Evocation", castingTime: "1 action", range: "Self (15-foot cone)", components: "V, S", duration: "Instantaneous", description: "As you hold your hands with thumbs touching and fingers spread, a thin sheet of flames shoots forth from your outstretched fingertips. Each creature in a 15-foot cone must make a Dexterity saving throw. A creature takes 3d6 fire damage on a failed save, or half as much damage on a successful one.", damage: "3d6", damageType: "fire", savingThrow: "Dexterity", classes: ["Sorcerer", "Wizard"]},
                    "Charm Person": {level: 1, school: "Enchantment", castingTime: "1 action", range: "30 feet", components: "V, S", duration: "1 hour", description: "You attempt to charm a humanoid you can see within range. It must make a Wisdom saving throw, and it does so with advantage if you or your companions are fighting it.", savingThrow: "Wisdom", classes: ["Bard", "Druid", "Sorcerer", "Warlock", "Wizard"]},
                    "Cure Wounds": {level: 1, school: "Evocation", castingTime: "1 action", range: "Touch", components: "V, S", duration: "Instantaneous", description: "A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier.", healing: "1d8", classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger"]},
                    "Detect Magic": {level: 1, school: "Divination", castingTime: "1 action", range: "Self", components: "V, S", duration: "Concentration, up to 10 minutes", description: "For the duration, you sense the presence of magic within 30 feet of you. If you sense magic in this way, you can use your action to see a faint aura around any visible creature or object in the area that bears magic.", classes: ["Bard", "Cleric", "Druid", "Paladin", "Ranger", "Sorcerer", "Wizard"]},
                    "Faerie Fire": {level: 1, school: "Evocation", castingTime: "1 action", range: "60 feet", components: "V", duration: "Concentration, up to 1 minute", description: "Each object in a 20-foot cube within range is outlined in blue, green, or violet light (your choice). Any creature in the area when the spell is cast is also outlined in light if it fails a Dexterity saving throw.", savingThrow: "Dexterity", classes: ["Bard", "Druid"]},
                    "False Life": {level: 1, school: "Necromancy", castingTime: "1 action", range: "Self", components: "V, S, M", duration: "1 hour", description: "Bolstering yourself with a necromantic facsimile of life, you gain 1d4 + 4 temporary hit points for the duration.", healing: "1d4+4", classes: ["Sorcerer", "Wizard"]},
                    "Healing Word": {level: 1, school: "Evocation", castingTime: "1 bonus action", range: "60 feet", components: "V", duration: "Instantaneous", description: "A creature of your choice that you can see within range regains hit points equal to 1d4 + your spellcasting ability modifier. This spell has no effect on undead or constructs.", healing: "1d4", classes: ["Bard", "Cleric", "Druid"]},
                    "Hex": {level: 1, school: "Enchantment", castingTime: "1 bonus action", range: "90 feet", components: "V, S, M", duration: "Concentration, up to 1 hour", description: "You place a curse on a creature that you can see within range. Until the spell ends, you deal an extra 1d6 necrotic damage to the target whenever you hit it with an attack.", damage: "1d6", damageType: "necrotic", classes: ["Warlock"]},
                    "Hunter's Mark": {level: 1, school: "Divination", castingTime: "1 bonus action", range: "90 feet", components: "V", duration: "Concentration, up to 1 hour", description: "You choose a creature you can see within range and mystically mark it as your quarry. Until the spell ends, you deal an extra 1d6 damage to the target whenever you hit it with a weapon attack.", damage: "1d6", classes: ["Ranger"]},
                    "Identify": {level: 1, school: "Divination", castingTime: "1 minute", range: "Touch", components: "V, S, M", duration: "Instantaneous", description: "You choose one object that you must touch throughout the casting of the spell. If it is a magic item or some other magic-imbued object, you learn its properties and how to use them.", classes: ["Bard", "Wizard"]},
                    "Magic Missile": {level: 1, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "Instantaneous", description: "You create three glowing darts of magical force. Each dart hits a creature of your choice that you can see within range. A dart deals 1d4 + 1 force damage to its target.", damage: "1d4+1", damageType: "force", autoHit: true, classes: ["Sorcerer", "Wizard"]},
                    "Shield": {level: 1, school: "Abjuration", castingTime: "1 reaction", range: "Self", components: "V, S", duration: "1 round", description: "An invisible barrier of magical force appears and protects you. Until the start of your next turn, you have a +5 bonus to AC, including against the triggering attack.", classes: ["Sorcerer", "Wizard"]},
                    "Sleep": {level: 1, school: "Enchantment", castingTime: "1 action", range: "90 feet", components: "V, S, M", duration: "1 minute", description: "This spell sends creatures into a magical slumber. Roll 5d8; the total is how many hit points of creatures this spell can affect.", classes: ["Bard", "Sorcerer", "Wizard"]},
                    "Thunderwave": {level: 1, school: "Evocation", castingTime: "1 action", range: "Self (15-foot cube)", components: "V, S", duration: "Instantaneous", description: "A wave of thunderous force sweeps out from you. Each creature in a 15-foot cube originating from you must make a Constitution saving throw. On a failed save, a creature takes 2d8 thunder damage and is pushed 10 feet away from you.", damage: "2d8", damageType: "thunder", savingThrow: "Constitution", classes: ["Bard", "Druid", "Sorcerer", "Wizard"]}
                },
                level2: {
                    "Aid": {level: 2, school: "Abjuration", castingTime: "1 action", range: "30 feet", components: "V, S, M", duration: "8 hours", description: "Your spell bolsters your allies with toughness and resolve. Choose up to three creatures within range. Each target's hit point maximum and current hit points increase by 5 for the duration.", healing: "5", classes: ["Cleric", "Paladin"]},
                    "Blur": {level: 2, school: "Illusion", castingTime: "1 action", range: "Self", components: "V", duration: "Concentration, up to 1 minute", description: "Your body becomes blurred, shifting and wavering to all who can see you. For the duration, any creature has disadvantage on attack rolls against you.", classes: ["Sorcerer", "Wizard"]},
                    "Hold Person": {level: 2, school: "Enchantment", castingTime: "1 action", range: "60 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "Choose a humanoid that you can see within range. The target must succeed on a Wisdom saving throw or be paralyzed for the duration.", savingThrow: "Wisdom", classes: ["Bard", "Cleric", "Druid", "Sorcerer", "Warlock", "Wizard"]},
                    "Invisibility": {level: 2, school: "Illusion", castingTime: "1 action", range: "Touch", components: "V, S, M", duration: "Concentration, up to 1 hour", description: "A creature you touch becomes invisible until the spell ends. Anything the target is wearing or carrying is invisible as long as it is on the target's person.", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Misty Step": {level: 2, school: "Conjuration", castingTime: "1 bonus action", range: "Self", components: "V", duration: "Instantaneous", description: "Briefly surrounded by silvery mist, you teleport up to 30 feet to an unoccupied space that you can see.", classes: ["Sorcerer", "Warlock", "Wizard"]},
                    "Scorching Ray": {level: 2, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "Instantaneous", description: "You create three rays of fire and hurl them at targets within range. You can hurl them at one target or several. Make a ranged spell attack for each ray. On a hit, the target takes 2d6 fire damage.", damage: "2d6", damageType: "fire", attack: "ranged", classes: ["Sorcerer", "Wizard"]},
                    "Web": {level: 2, school: "Conjuration", castingTime: "1 action", range: "60 feet", components: "V, S, M", duration: "Concentration, up to 1 hour", description: "You conjure a mass of thick, sticky webbing at a point of your choice within range. The webs fill a 20-foot cube from that point for the duration.", savingThrow: "Dexterity", classes: ["Sorcerer", "Wizard"]}
                },
                level3: {
                    "Counterspell": {level: 3, school: "Abjuration", castingTime: "1 reaction", range: "60 feet", components: "S", duration: "Instantaneous", description: "You attempt to interrupt a creature in the process of casting a spell. If the creature is casting a spell of 3rd level or lower, its spell fails and has no effect.", classes: ["Sorcerer", "Warlock", "Wizard"]},
                    "Fireball": {level: 3, school: "Evocation", castingTime: "1 action", range: "150 feet", components: "V, S, M", duration: "Instantaneous", description: "A bright flash of light streaks toward a point you choose within range then blossoms with a low roar into an explosion of flame. Each creature in a 20-foot-radius sphere centered on that point must make a Dexterity saving throw. A target takes 8d6 fire damage on a failed save, or half as much damage on a successful one.", damage: "8d6", damageType: "fire", savingThrow: "Dexterity", classes: ["Sorcerer", "Wizard"]},
                    "Haste": {level: 3, school: "Transmutation", castingTime: "1 action", range: "30 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "Choose a willing creature that you can see within range. Until the spell ends, the target's speed is doubled, it gains a +2 bonus to AC, it has advantage on Dexterity saving throws, and it gains an additional action on each of its turns.", classes: ["Sorcerer", "Wizard"]},
                    "Lightning Bolt": {level: 3, school: "Evocation", castingTime: "1 action", range: "Self (100-foot line)", components: "V, S, M", duration: "Instantaneous", description: "A stroke of lightning forming a line 100 feet long and 5 feet wide blasts out from you in a direction you choose. Each creature in the line must make a Dexterity saving throw. A creature takes 8d6 lightning damage on a failed save, or half as much damage on a successful one.", damage: "8d6", damageType: "lightning", savingThrow: "Dexterity", classes: ["Sorcerer", "Wizard"]},
                    "Dispel Magic": {level: 3, school: "Abjuration", castingTime: "1 action", range: "120 feet", components: "V, S", duration: "Instantaneous", description: "Choose one creature, object, or magical effect within range. Any spell of 3rd level or lower on the target ends. For each spell of 4th level or higher on the target, make an ability check using your spellcasting ability.", classes: ["Bard", "Cleric", "Druid", "Paladin", "Sorcerer", "Warlock", "Wizard"]},
                    "Fly": {level: 3, school: "Transmutation", castingTime: "1 action", range: "Touch", components: "V, S, M", duration: "Concentration, up to 10 minutes", description: "You touch a willing creature. The target gains a flying speed of 60 feet for the duration. When the spell ends, the target falls if it is still aloft, unless it can stop the fall.", classes: ["Sorcerer", "Warlock", "Wizard"]}
                },
                level4: {
                    "Confusion": {level: 4, school: "Enchantment", castingTime: "1 action", range: "90 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "This spell assaults and twists creatures' minds, spawning delusions and provoking uncontrolled action. Each creature in a 10-foot-radius sphere centered on a point you choose within range must succeed on a Wisdom saving throw when you cast this spell or be affected by it.", savingThrow: "Wisdom", classes: ["Bard", "Druid", "Sorcerer", "Wizard"]},
                    "Greater Invisibility": {level: 4, school: "Illusion", castingTime: "1 action", range: "Touch", components: "V, S", duration: "Concentration, up to 1 minute", description: "You or a creature you touch becomes invisible until the spell ends. Anything the target is wearing or carrying is invisible as long as it is on the target's person.", classes: ["Bard", "Sorcerer", "Wizard"]},
                    "Polymorph": {level: 4, school: "Transmutation", castingTime: "1 action", range: "60 feet", components: "V, S, M", duration: "Concentration, up to 1 hour", description: "This spell transforms a creature that you can see within range into a new form. An unwilling creature must make a Wisdom saving throw to avoid the effect. The spell has no effect on a shapechanger or a creature with 0 hit points.", savingThrow: "Wisdom", classes: ["Bard", "Druid", "Sorcerer", "Wizard"]},
                    "Wall of Fire": {level: 4, school: "Evocation", castingTime: "1 action", range: "120 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "You create a wall of fire on a solid surface within range. You can make the wall up to 60 feet long, 20 feet high, and 1 foot thick, or a ringed wall up to 20 feet in diameter, 20 feet high, and 1 foot thick.", damage: "5d8", damageType: "fire", classes: ["Druid", "Sorcerer", "Wizard"]}
                },
                level5: {
                    "Cone of Cold": {level: 5, school: "Evocation", castingTime: "1 action", range: "Self (60-foot cone)", components: "V, S, M", duration: "Instantaneous", description: "A blast of cold air erupts from your hands. Each creature in a 60-foot cone must make a Constitution saving throw. A creature takes 8d8 cold damage on a failed save, or half as much damage on a successful one.", damage: "8d8", damageType: "cold", savingThrow: "Constitution", classes: ["Sorcerer", "Wizard"]},
                    "Hold Monster": {level: 5, school: "Enchantment", castingTime: "1 action", range: "90 feet", components: "V, S, M", duration: "Concentration, up to 1 minute", description: "Choose a creature that you can see within range. The target must succeed on a Wisdom saving throw or be paralyzed for the duration. This spell has no effect on undead.", savingThrow: "Wisdom", classes: ["Bard", "Sorcerer", "Warlock", "Wizard"]},
                    "Teleport": {level: 5, school: "Conjuration", castingTime: "1 action", range: "10 feet", components: "V", duration: "Instantaneous", description: "This spell instantly transports you and up to eight willing creatures of your choice that you can see within range, or a single object that you can see within range, to a destination you select.", classes: ["Bard", "Sorcerer", "Wizard"]}
                }
            },
            
            // Monsters Database (comprehensive)
            monsters: {
                "Goblin": {
                    name: "Goblin",
                    size: "Small",
                    type: "humanoid",
                    alignment: "neutral evil",
                    ac: 15,
                    hp: 7,
                    hitDice: "2d6",
                    speed: {walk: 30},
                    abilities: {str: 8, dex: 14, con: 10, int: 10, wis: 8, cha: 8},
                    saves: {},
                    skills: {stealth: 6},
                    senses: "darkvision 60 ft., passive Perception 9",
                    languages: "Common, Goblin",
                    cr: "1/4",
                    xp: 50,
                    traits: [
                        {name: "Nimble Escape", description: "The goblin can take the Disengage or Hide action as a bonus action on each of its turns."}
                    ],
                    actions: [
                        {
                            name: "Scimitar",
                            description: "Melee Weapon Attack: +4 to hit, reach 5 ft., one target. Hit: 5 (1d6 + 2) slashing damage.",
                            attack: {bonus: 4, damage: "1d6+2", damageType: "slashing", range: 5}
                        },
                        {
                            name: "Shortbow",
                            description: "Ranged Weapon Attack: +4 to hit, range 80/320 ft., one target. Hit: 5 (1d6 + 2) piercing damage.",
                            attack: {bonus: 4, damage: "1d6+2", damageType: "piercing", range: "80/320"}
                        }
                    ]
                },
                "Orc": {
                    name: "Orc",
                    size: "Medium",
                    type: "humanoid",
                    alignment: "chaotic evil",
                    ac: 13,
                    hp: 15,
                    hitDice: "2d8+2",
                    speed: {walk: 30},
                    abilities: {str: 16, dex: 12, con: 13, int: 7, wis: 11, cha: 10},
                    saves: {},
                    skills: {},
                    senses: "darkvision 60 ft., passive Perception 10",
                    languages: "Common, Orc",
                    cr: "1/2",
                    xp: 100,
                    traits: [
                        {name: "Aggressive", description: "As a bonus action, the orc can move up to its speed toward a hostile creature that it can see."}
                    ],
                    actions: [
                        {
                            name: "Greataxe",
                            description: "Melee Weapon Attack: +5 to hit, reach 5 ft., one target. Hit: 9 (1d12 + 3) slashing damage.",
                            attack: {bonus: 5, damage: "1d12+3", damageType: "slashing", range: 5}
                        },
                        {
                            name: "Javelin",
                            description: "Melee or Ranged Weapon Attack: +5 to hit, reach 5 ft. or range 30/120 ft., one target. Hit: 6 (1d6 + 3) piercing damage.",
                            attack: {bonus: 5, damage: "1d6+3", damageType: "piercing", range: "5 ft. or 30/120"}
                        }
                    ]
                },
                "Troll": {
                    name: "Troll",
                    size: "Large",
                    type: "giant",
                    alignment: "chaotic evil",
                    ac: 15,
                    hp: 84,
                    hitDice: "8d12+16",
                    speed: {walk: 30},
                    abilities: {str: 18, dex: 13, con: 20, int: 7, wis: 9, cha: 7},
                    saves: {},
                    skills: {perception: 2},
                    senses: "darkvision 60 ft., passive Perception 12",
                    languages: "Giant",
                    cr: "5",
                    xp: 1800,
                    traits: [
                        {
                            name: "Keen Smell",
                            description: "The troll has advantage on Wisdom (Perception) checks that rely on smell."
                        },
                        {
                            name: "Regeneration",
                            description: "The troll regains 10 hit points at the start of its turn. If the troll takes acid or fire damage, this trait doesn't function at the start of the troll's next turn. The troll dies only if it starts its turn with 0 hit points and doesn't regenerate."
                        }
                    ],
                    actions: [
                        {
                            name: "Multiattack",
                            description: "The troll makes three attacks: one with its bite and two with its claws."
                        },
                        {
                            name: "Bite",
                            description: "Melee Weapon Attack: +7 to hit, reach 5 ft., one target. Hit: 7 (1d6 + 4) piercing damage.",
                            attack: {bonus: 7, damage: "1d6+4", damageType: "piercing", range: 5}
                        },
                        {
                            name: "Claw",
                            description: "Melee Weapon Attack: +7 to hit, reach 5 ft., one target. Hit: 11 (2d6 + 4) slashing damage.",
                            attack: {bonus: 7, damage: "2d6+4", damageType: "slashing", range: 5}
                        }
                    ]
                },
                "Skeleton": {
                    name: "Skeleton",
                    size: "Medium",
                    type: "undead",
                    alignment: "lawful evil",
                    ac: 13,
                    hp: 13,
                    hitDice: "2d8+2",
                    speed: {walk: 30},
                    abilities: {str: 10, dex: 14, con: 15, int: 6, wis: 8, cha: 5},
                    saves: {},
                    skills: {},
                    immunities: "poison",
                    resistances: "cold, necrotic",
                    vulnerabilities: "bludgeoning",
                    senses: "darkvision 60 ft., passive Perception 9",
                    languages: "understands all languages it knew in life but can't speak",
                    cr: "1/4",
                    xp: 50,
                    traits: [],
                    actions: [
                        {
                            name: "Shortsword",
                            description: "Melee Weapon Attack: +4 to hit, reach 5 ft., one target. Hit: 5 (1d6 + 2) piercing damage.",
                            attack: {bonus: 4, damage: "1d6+2", damageType: "piercing", range: 5}
                        },
                        {
                            name: "Shortbow",
                            description: "Ranged Weapon Attack: +4 to hit, range 80/320 ft., one target. Hit: 5 (1d6 + 2) piercing damage.",
                            attack: {bonus: 4, damage: "1d6+2", damageType: "piercing", range: "80/320"}
                        }
                    ]
                },
                "Zombie": {
                    name: "Zombie",
                    size: "Medium",
                    type: "undead",
                    alignment: "neutral evil",
                    ac: 8,
                    hp: 22,
                    hitDice: "3d8+9",
                    speed: {walk: 20},
                    abilities: {str: 13, dex: 6, con: 16, int: 3, wis: 6, cha: 5},
                    saves: {wis: 0},
                    skills: {},
                    immunities: "poison",
                    senses: "darkvision 60 ft., passive Perception 8",
                    languages: "understands the languages it knew in life but can't speak",
                    cr: "1/4",
                    xp: 50,
                    traits: [
                        {
                            name: "Undead Fortitude",
                            description: "If damage reduces the zombie to 0 hit points, it must make a Constitution saving throw with a DC of 5 + the damage taken, unless the damage is radiant or from a critical hit. On a success, the zombie drops to 1 hit point instead."
                        }
                    ],
                    actions: [
                        {
                            name: "Slam",
                            description: "Melee Weapon Attack: +3 to hit, reach 5 ft., one target. Hit: 4 (1d6 + 1) bludgeoning damage.",
                            attack: {bonus: 3, damage: "1d6+1", damageType: "bludgeoning", range: 5}
                        }
                    ]
                },
                "Wolf": {
                    name: "Wolf",
                    size: "Medium",
                    type: "beast",
                    alignment: "unaligned",
                    ac: 13,
                    hp: 11,
                    hitDice: "2d8+2",
                    speed: {walk: 40},
                    abilities: {str: 12, dex: 15, con: 12, int: 3, wis: 12, cha: 6},
                    saves: {},
                    skills: {perception: 3, stealth: 4},
                    senses: "passive Perception 13",
                    languages: "—",
                    cr: "1/4",
                    xp: 50,
                    traits: [
                        {
                            name: "Keen Hearing and Smell",
                            description: "The wolf has advantage on Wisdom (Perception) checks that rely on hearing or smell."
                        },
                        {
                            name: "Pack Tactics",
                            description: "The wolf has advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally isn't incapacitated."
                        }
                    ],
                    actions: [
                        {
                            name: "Bite",
                            description: "Melee Weapon Attack: +4 to hit, reach 5 ft., one target. Hit: 7 (2d4 + 2) piercing damage. If the target is a creature, it must succeed on a DC 11 Strength saving throw or be knocked prone.",
                            attack: {bonus: 4, damage: "2d4+2", damageType: "piercing", range: 5, savingThrow: {ability: "strength", dc: 11, effect: "knocked prone"}}
                        }
                    ]
                },
                "Owlbear": {
                    name: "Owlbear",
                    size: "Large",
                    type: "monstrosity",
                    alignment: "unaligned",
                    ac: 13,
                    hp: 59,
                    hitDice: "7d10+21",
                    speed: {walk: 40},
                    abilities: {str: 20, dex: 12, con: 17, int: 3, wis: 12, cha: 7},
                    saves: {},
                    skills: {perception: 3},
                    senses: "darkvision 60 ft., passive Perception 13",
                    languages: "—",
                    cr: "3",
                    xp: 700,
                    traits: [
                        {
                            name: "Keen Sight and Smell",
                            description: "The owlbear has advantage on Wisdom (Perception) checks that rely on sight or smell."
                        }
                    ],
                    actions: [
                        {
                            name: "Multiattack",
                            description: "The owlbear makes two attacks: one with its beak and one with its claws."
                        },
                        {
                            name: "Beak",
                            description: "Melee Weapon Attack: +7 to hit, reach 5 ft., one creature. Hit: 10 (1d10 + 5) piercing damage.",
                            attack: {bonus: 7, damage: "1d10+5", damageType: "piercing", range: 5}
                        },
                        {
                            name: "Claws",
                            description: "Melee Weapon Attack: +7 to hit, reach 5 ft., one target. Hit: 14 (2d8 + 5) slashing damage.",
                            attack: {bonus: 7, damage: "2d8+5", damageType: "slashing", range: 5}
                        }
                    ]
                },
                "Bandit": {
                    name: "Bandit",
                    size: "Medium",
                    type: "humanoid",
                    alignment: "any non-lawful",
                    ac: 12,
                    hp: 11,
                    hitDice: "2d8+2",
                    speed: {walk: 30},
                    abilities: {str: 11, dex: 12, con: 12, int: 10, wis: 10, cha: 10},
                    saves: {},
                    skills: {},
                    senses: "passive Perception 10",
                    languages: "any one language (usually Common)",
                    cr: "1/8",
                    xp: 25,
                    traits: [],
                    actions: [
                        {
                            name: "Scimitar",
                            description: "Melee Weapon Attack: +3 to hit, reach 5 ft., one target. Hit: 4 (1d6 + 1) slashing damage.",
                            attack: {bonus: 3, damage: "1d6+1", damageType: "slashing", range: 5}
                        },
                        {
                            name: "Light Crossbow",
                            description: "Ranged Weapon Attack: +3 to hit, range 80/320 ft., one target. Hit: 5 (1d8 + 1) piercing damage.",
                            attack: {bonus: 3, damage: "1d8+1", damageType: "piercing", range: "80/320"}
                        }
                    ]
                },
                "Dragon, Adult Red": {
                    name: "Adult Red Dragon",
                    size: "Huge",
                    type: "dragon",
                    alignment: "chaotic evil",
                    ac: 19,
                    hp: 256,
                    hitDice: "19d12+133",
                    speed: {walk: 40, climb: 40, fly: 80},
                    abilities: {str: 27, dex: 10, con: 25, int: 16, wis: 13, cha: 21},
                    saves: {dex: 6, con: 13, wis: 7, cha: 11},
                    skills: {perception: 13, stealth: 6},
                    immunities: "fire",
                    senses: "blindsight 60 ft., darkvision 120 ft., passive Perception 23",
                    languages: "Common, Draconic",
                    cr: "17",
                    xp: 18000,
                    traits: [
                        {
                            name: "Legendary Resistance (3/Day)",
                            description: "If the dragon fails a saving throw, it can choose to succeed instead."
                        }
                    ],
                    actions: [
                        {
                            name: "Multiattack",
                            description: "The dragon can use its Frightful Presence. It then makes three attacks: one with its bite and two with its claws."
                        },
                        {
                            name: "Bite",
                            description: "Melee Weapon Attack: +14 to hit, reach 10 ft., one target. Hit: 19 (2d10 + 8) piercing damage plus 7 (2d6) fire damage.",
                            attack: {bonus: 14, damage: "2d10+8", damageType: "piercing", extraDamage: "2d6", extraDamageType: "fire", range: 10}
                        },
                        {
                            name: "Fire Breath (Recharge 5-6)",
                            description: "The dragon exhales fire in a 60-foot cone. Each creature in that area must make a DC 21 Dexterity saving throw, taking 63 (18d6) fire damage on a failed save, or half as much damage on a successful one.",
                            savingThrow: {ability: "dexterity", dc: 21, damage: "18d6", damageType: "fire", halfOnSave: true}
                        }
                    ],
                    legendary_actions: [
                        "Detect: The dragon makes a Wisdom (Perception) check.",
                        "Tail Attack: The dragon makes a tail attack.",
                        "Wing Attack (Costs 2 Actions): The dragon beats its wings."
                    ]
                },
                "Dire Wolf": {
                    name: "Dire Wolf",
                    size: "Large",
                    type: "beast",
                    alignment: "unaligned",
                    ac: 14,
                    hp: 37,
                    hitDice: "5d10+10",
                    speed: {walk: 50},
                    abilities: {str: 17, dex: 15, con: 15, int: 3, wis: 12, cha: 7},
                    saves: {},
                    skills: {perception: 3, stealth: 4},
                    senses: "passive Perception 13",
                    languages: "—",
                    cr: "1",
                    xp: 200,
                    traits: [
                        {
                            name: "Keen Hearing and Smell",
                            description: "The wolf has advantage on Wisdom (Perception) checks that rely on hearing or smell."
                        },
                        {
                            name: "Pack Tactics",
                            description: "The wolf has advantage on an attack roll against a creature if at least one of the wolf's allies is within 5 feet of the creature and the ally isn't incapacitated."
                        }
                    ],
                    actions: [
                        {
                            name: "Bite",
                            description: "Melee Weapon Attack: +5 to hit, reach 5 ft., one target. Hit: 10 (2d6 + 3) piercing damage. If the target is a creature, it must succeed on a DC 13 Strength saving throw or be knocked prone.",
                            attack: {bonus: 5, damage: "2d6+3", damageType: "piercing", range: 5, savingThrow: {ability: "strength", dc: 13, effect: "knocked prone"}}
                        }
                    ]
                },
                "Ogre": {
                    name: "Ogre",
                    size: "Large",
                    type: "giant",
                    alignment: "chaotic evil",
                    ac: 11,
                    hp: 59,
                    hitDice: "7d10+21",
                    speed: {walk: 40},
                    abilities: {str: 19, dex: 8, con: 16, int: 5, wis: 7, cha: 7},
                    saves: {},
                    skills: {},
                    senses: "darkvision 60 ft., passive Perception 8",
                    languages: "Common, Giant",
                    cr: "2",
                    xp: 450,
                    traits: [],
                    actions: [
                        {
                            name: "Greatclub",
                            description: "Melee Weapon Attack: +6 to hit, reach 5 ft., one target. Hit: 13 (2d8 + 4) bludgeoning damage.",
                            attack: {bonus: 6, damage: "2d8+4", damageType: "bludgeoning", range: 5}
                        },
                        {
                            name: "Javelin",
                            description: "Melee or Ranged Weapon Attack: +6 to hit, reach 5 ft. or range 30/120 ft., one target. Hit: 11 (2d6 + 4) piercing damage.",
                            attack: {bonus: 6, damage: "2d6+4", damageType: "piercing", range: "5 ft. or 30/120"}
                        }
                    ]
                },
                "Bugbear": {
                    name: "Bugbear",
                    size: "Medium",
                    type: "humanoid",
                    alignment: "chaotic evil",
                    ac: 16,
                    hp: 27,
                    hitDice: "5d8+5",
                    speed: {walk: 30},
                    abilities: {str: 15, dex: 14, con: 13, int: 8, wis: 11, cha: 9},
                    saves: {},
                    skills: {stealth: 6, survival: 2},
                    senses: "darkvision 60 ft., passive Perception 10",
                    languages: "Common, Goblin",
                    cr: "1",
                    xp: 200,
                    traits: [
                        {
                            name: "Brute",
                            description: "A melee weapon deals one extra die of its damage when the bugbear hits with it (included in the attack)."
                        },
                        {
                            name: "Surprise Attack",
                            description: "If the bugbear surprises a creature and hits it with an attack during the first round of combat, the target takes an extra 7 (2d6) damage from the attack."
                        }
                    ],
                    actions: [
                        {
                            name: "Morningstar",
                            description: "Melee Weapon Attack: +4 to hit, reach 5 ft., one target. Hit: 11 (2d8 + 2) piercing damage.",
                            attack: {bonus: 4, damage: "2d8+2", damageType: "piercing", range: 5}
                        },
                        {
                            name: "Javelin",
                            description: "Melee or Ranged Weapon Attack: +4 to hit, reach 5 ft. or range 30/120 ft., one target. Hit: 9 (2d6 + 2) piercing damage in melee or 5 (1d6 + 2) piercing damage at range.",
                            attack: {bonus: 4, damage: "2d6+2", damageType: "piercing", range: "5 ft. or 30/120"}
                        }
                    ]
                },
                "Minotaur": {
                    name: "Minotaur",
                    size: "Large",
                    type: "monstrosity",
                    alignment: "chaotic evil",
                    ac: 14,
                    hp: 76,
                    hitDice: "9d10+27",
                    speed: {walk: 40},
                    abilities: {str: 18, dex: 11, con: 16, int: 6, wis: 16, cha: 9},
                    saves: {},
                    skills: {perception: 7},
                    senses: "darkvision 60 ft., passive Perception 17",
                    languages: "Abyssal",
                    cr: "3",
                    xp: 700,
                    traits: [
                        {
                            name: "Charge",
                            description: "If the minotaur moves at least 10 feet straight toward a target and then hits it with a gore attack on the same turn, the target takes an extra 9 (2d8) piercing damage. If the target is a creature, it must succeed on a DC 14 Strength saving throw or be pushed up to 10 feet away and knocked prone."
                        },
                        {
                            name: "Labyrinthine Recall",
                            description: "The minotaur can perfectly recall any path it has traveled."
                        },
                        {
                            name: "Reckless",
                            description: "At the start of its turn, the minotaur can gain advantage on all melee weapon attack rolls during that turn, but attack rolls against it have advantage until the start of its next turn."
                        }
                    ],
                    actions: [
                        {
                            name: "Greataxe",
                            description: "Melee Weapon Attack: +6 to hit, reach 5 ft., one target. Hit: 17 (2d12 + 4) slashing damage.",
                            attack: {bonus: 6, damage: "2d12+4", damageType: "slashing", range: 5}
                        },
                        {
                            name: "Gore",
                            description: "Melee Weapon Attack: +6 to hit, reach 5 ft., one target. Hit: 13 (2d8 + 4) piercing damage.",
                            attack: {bonus: 6, damage: "2d8+4", damageType: "piercing", range: 5}
                        }
                    ]
                }
            },
            
            // Equipment Database (Comprehensive D&D 5e)
            equipment: {
                weapons: {
                    // Simple Melee Weapons
                    "Club": {name: "Club", type: "Simple Melee", cost: "1 sp", damage: "1d4", damageType: "bludgeoning", weight: 2, properties: ["Light"]},
                    "Dagger": {name: "Dagger", type: "Simple Melee", cost: "2 gp", damage: "1d4", damageType: "piercing", weight: 1, properties: ["Finesse", "Light", "Thrown (range 20/60)"]},
                    "Dart": {name: "Dart", type: "Simple Ranged", cost: "5 cp", damage: "1d4", damageType: "piercing", weight: 0.25, properties: ["Finesse", "Thrown (range 20/60)"]},
                    "Handaxe": {name: "Handaxe", type: "Simple Melee", cost: "5 gp", damage: "1d6", damageType: "slashing", weight: 2, properties: ["Light", "Thrown (range 20/60)"]},
                    "Javelin": {name: "Javelin", type: "Simple Melee", cost: "5 sp", damage: "1d6", damageType: "piercing", weight: 2, properties: ["Thrown (range 30/120)"]},
                    "Light Hammer": {name: "Light Hammer", type: "Simple Melee", cost: "2 gp", damage: "1d4", damageType: "bludgeoning", weight: 2, properties: ["Light", "Thrown (range 20/60)"]},
                    "Mace": {name: "Mace", type: "Simple Melee", cost: "5 gp", damage: "1d6", damageType: "bludgeoning", weight: 4, properties: []},
                    "Quarterstaff": {name: "Quarterstaff", type: "Simple Melee", cost: "2 sp", damage: "1d6", damageType: "bludgeoning", weight: 4, properties: ["Versatile (1d8)"]},
                    "Sickle": {name: "Sickle", type: "Simple Melee", cost: "1 gp", damage: "1d4", damageType: "slashing", weight: 2, properties: ["Light"]},
                    "Spear": {name: "Spear", type: "Simple Melee", cost: "1 gp", damage: "1d6", damageType: "piercing", weight: 3, properties: ["Thrown (range 20/60)", "Versatile (1d8)"]},
                    
                    // Simple Ranged Weapons
                    "Light Crossbow": {name: "Light Crossbow", type: "Simple Ranged", cost: "25 gp", damage: "1d8", damageType: "piercing", weight: 5, properties: ["Ammunition (range 80/320)", "Loading", "Two-handed"]},
                    "Shortbow": {name: "Shortbow", type: "Simple Ranged", cost: "25 gp", damage: "1d6", damageType: "piercing", weight: 2, properties: ["Ammunition (range 80/320)", "Two-handed"]},
                    "Sling": {name: "Sling", type: "Simple Ranged", cost: "1 sp", damage: "1d4", damageType: "bludgeoning", weight: 0, properties: ["Ammunition (range 30/120)"]},
                    
                    // Martial Melee Weapons
                    "Battleaxe": {name: "Battleaxe", type: "Martial Melee", cost: "10 gp", damage: "1d8", damageType: "slashing", weight: 4, properties: ["Versatile (1d10)"]},
                    "Flail": {name: "Flail", type: "Martial Melee", cost: "10 gp", damage: "1d8", damageType: "bludgeoning", weight: 2, properties: []},
                    "Glaive": {name: "Glaive", type: "Martial Melee", cost: "20 gp", damage: "1d10", damageType: "slashing", weight: 6, properties: ["Heavy", "Reach", "Two-handed"]},
                    "Greataxe": {name: "Greataxe", type: "Martial Melee", cost: "30 gp", damage: "1d12", damageType: "slashing", weight: 7, properties: ["Heavy", "Two-handed"]},
                    "Greatsword": {name: "Greatsword", type: "Martial Melee", cost: "50 gp", damage: "2d6", damageType: "slashing", weight: 6, properties: ["Heavy", "Two-handed"]},
                    "Halberd": {name: "Halberd", type: "Martial Melee", cost: "20 gp", damage: "1d10", damageType: "slashing", weight: 6, properties: ["Heavy", "Reach", "Two-handed"]},
                    "Lance": {name: "Lance", type: "Martial Melee", cost: "10 gp", damage: "1d12", damageType: "piercing", weight: 6, properties: ["Reach", "Special"]},
                    "Longsword": {name: "Longsword", type: "Martial Melee", cost: "15 gp", damage: "1d8", damageType: "slashing", weight: 3, properties: ["Versatile (1d10)"]},
                    "Maul": {name: "Maul", type: "Martial Melee", cost: "10 gp", damage: "2d6", damageType: "bludgeoning", weight: 10, properties: ["Heavy", "Two-handed"]},
                    "Morningstar": {name: "Morningstar", type: "Martial Melee", cost: "15 gp", damage: "1d8", damageType: "piercing", weight: 4, properties: []},
                    "Pike": {name: "Pike", type: "Martial Melee", cost: "5 gp", damage: "1d10", damageType: "piercing", weight: 18, properties: ["Heavy", "Reach", "Two-handed"]},
                    "Rapier": {name: "Rapier", type: "Martial Melee", cost: "25 gp", damage: "1d8", damageType: "piercing", weight: 2, properties: ["Finesse"]},
                    "Scimitar": {name: "Scimitar", type: "Martial Melee", cost: "25 gp", damage: "1d6", damageType: "slashing", weight: 3, properties: ["Finesse", "Light"]},
                    "Shortsword": {name: "Shortsword", type: "Martial Melee", cost: "10 gp", damage: "1d6", damageType: "piercing", weight: 2, properties: ["Finesse", "Light"]},
                    "Trident": {name: "Trident", type: "Martial Melee", cost: "5 gp", damage: "1d6", damageType: "piercing", weight: 4, properties: ["Thrown (range 20/60)", "Versatile (1d8)"]},
                    "War Pick": {name: "War Pick", type: "Martial Melee", cost: "5 gp", damage: "1d8", damageType: "piercing", weight: 2, properties: []},
                    "Warhammer": {name: "Warhammer", type: "Martial Melee", cost: "15 gp", damage: "1d8", damageType: "bludgeoning", weight: 2, properties: ["Versatile (1d10)"]},
                    "Whip": {name: "Whip", type: "Martial Melee", cost: "2 gp", damage: "1d4", damageType: "slashing", weight: 3, properties: ["Finesse", "Reach"]},
                    
                    // Martial Ranged Weapons
                    "Blowgun": {name: "Blowgun", type: "Martial Ranged", cost: "10 gp", damage: "1", damageType: "piercing", weight: 1, properties: ["Ammunition (range 25/100)", "Loading"]},
                    "Hand Crossbow": {name: "Hand Crossbow", type: "Martial Ranged", cost: "75 gp", damage: "1d6", damageType: "piercing", weight: 3, properties: ["Ammunition (range 30/120)", "Light", "Loading"]},
                    "Heavy Crossbow": {name: "Heavy Crossbow", type: "Martial Ranged", cost: "50 gp", damage: "1d10", damageType: "piercing", weight: 18, properties: ["Ammunition (range 100/400)", "Heavy", "Loading", "Two-handed"]},
                    "Longbow": {name: "Longbow", type: "Martial Ranged", cost: "50 gp", damage: "1d8", damageType: "piercing", weight: 2, properties: ["Ammunition (range 150/600)", "Heavy", "Two-handed"]},
                    "Net": {name: "Net", type: "Martial Ranged", cost: "1 gp", damage: "-", damageType: "special", weight: 3, properties: ["Special", "Thrown (range 5/15)"]}
                },
                armor: {
                    // Light Armor
                    "Padded": {name: "Padded", type: "Light Armor", cost: "5 gp", ac: 11, acCalc: "11 + Dex modifier", weight: 8, stealthDisadvantage: true},
                    "Leather": {name: "Leather", type: "Light Armor", cost: "10 gp", ac: 11, acCalc: "11 + Dex modifier", weight: 10, stealthDisadvantage: false},
                    "Studded Leather": {name: "Studded Leather", type: "Light Armor", cost: "45 gp", ac: 12, acCalc: "12 + Dex modifier", weight: 13, stealthDisadvantage: false},
                    
                    // Medium Armor
                    "Hide": {name: "Hide", type: "Medium Armor", cost: "10 gp", ac: 12, acCalc: "12 + Dex modifier (max 2)", weight: 12, stealthDisadvantage: false},
                    "Chain Shirt": {name: "Chain Shirt", type: "Medium Armor", cost: "50 gp", ac: 13, acCalc: "13 + Dex modifier (max 2)", weight: 20, stealthDisadvantage: false},
                    "Scale Mail": {name: "Scale Mail", type: "Medium Armor", cost: "50 gp", ac: 14, acCalc: "14 + Dex modifier (max 2)", weight: 45, stealthDisadvantage: true},
                    "Breastplate": {name: "Breastplate", type: "Medium Armor", cost: "400 gp", ac: 14, acCalc: "14 + Dex modifier (max 2)", weight: 20, stealthDisadvantage: false},
                    "Half Plate": {name: "Half Plate", type: "Medium Armor", cost: "750 gp", ac: 15, acCalc: "15 + Dex modifier (max 2)", weight: 40, stealthDisadvantage: true},
                    
                    // Heavy Armor
                    "Ring Mail": {name: "Ring Mail", type: "Heavy Armor", cost: "30 gp", ac: 14, acCalc: "14", weight: 40, requirements: "", stealthDisadvantage: true},
                    "Chain Mail": {name: "Chain Mail", type: "Heavy Armor", cost: "75 gp", ac: 16, acCalc: "16", weight: 55, requirements: "Str 13", stealthDisadvantage: true},
                    "Splint": {name: "Splint", type: "Heavy Armor", cost: "200 gp", ac: 17, acCalc: "17", weight: 60, requirements: "Str 15", stealthDisadvantage: true},
                    "Plate": {name: "Plate", type: "Heavy Armor", cost: "1,500 gp", ac: 18, acCalc: "18", weight: 65, requirements: "Str 15", stealthDisadvantage: true},
                    
                    // Shields
                    "Shield": {name: "Shield", type: "Shield", cost: "10 gp", ac: 2, acCalc: "+2 AC", weight: 6, stealthDisadvantage: false}
                },
                adventuringGear: {
                    "Abacus": {name: "Abacus", cost: "2 gp", weight: 2},
                    "Acid (vial)": {name: "Acid (vial)", cost: "25 gp", weight: 1, damage: "2d6 acid"},
                    "Alchemist's Fire (flask)": {name: "Alchemist's Fire (flask)", cost: "50 gp", weight: 1, damage: "1d4 fire"},
                    "Ammunition - Arrows (20)": {name: "Arrows (20)", cost: "1 gp", weight: 1},
                    "Ammunition - Bolts (20)": {name: "Crossbow Bolts (20)", cost: "1 gp", weight: 1.5},
                    "Ammunition - Sling Bullets (20)": {name: "Sling Bullets (20)", cost: "4 cp", weight: 1.5},
                    "Antitoxin (vial)": {name: "Antitoxin (vial)", cost: "50 gp", weight: 0},
                    "Backpack": {name: "Backpack", cost: "2 gp", weight: 5, capacity: "30 lb / 1 cubic foot"},
                    "Ball Bearings (bag of 1,000)": {name: "Ball Bearings (bag of 1,000)", cost: "1 gp", weight: 2},
                    "Barrel": {name: "Barrel", cost: "2 gp", weight: 70, capacity: "40 gallons liquid, 4 cubic feet solid"},
                    "Bedroll": {name: "Bedroll", cost: "1 gp", weight: 7},
                    "Bell": {name: "Bell", cost: "1 gp", weight: 0},
                    "Blanket": {name: "Blanket", cost: "5 sp", weight: 3},
                    "Block and Tackle": {name: "Block and Tackle", cost: "2 gp", weight: 5},
                    "Book": {name: "Book", cost: "25 gp", weight: 5},
                    "Bottle, Glass": {name: "Bottle, Glass", cost: "2 gp", weight: 2, capacity: "1.5 pints liquid"},
                    "Bucket": {name: "Bucket", cost: "5 cp", weight: 2, capacity: "3 gallons liquid, 1/2 cubic foot solid"},
                    "Caltrops (bag of 20)": {name: "Caltrops (bag of 20)", cost: "1 gp", weight: 2},
                    "Candle": {name: "Candle", cost: "1 cp", weight: 0},
                    "Case, Crossbow Bolt": {name: "Case, Crossbow Bolt", cost: "1 gp", weight: 1, capacity: "20 crossbow bolts"},
                    "Case, Map or Scroll": {name: "Case, Map or Scroll", cost: "1 gp", weight: 1},
                    "Chain (10 feet)": {name: "Chain (10 feet)", cost: "5 gp", weight: 10},
                    "Chalk (1 piece)": {name: "Chalk (1 piece)", cost: "1 cp", weight: 0},
                    "Chest": {name: "Chest", cost: "5 gp", weight: 25, capacity: "12 cubic feet/300 pounds"},
                    "Climber's Kit": {name: "Climber's Kit", cost: "25 gp", weight: 12},
                    "Clothes, Common": {name: "Clothes, Common", cost: "5 sp", weight: 3},
                    "Clothes, Costume": {name: "Clothes, Costume", cost: "5 gp", weight: 4},
                    "Clothes, Fine": {name: "Clothes, Fine", cost: "15 gp", weight: 6},
                    "Clothes, Traveler's": {name: "Clothes, Traveler's", cost: "2 gp", weight: 4},
                    "Component Pouch": {name: "Component Pouch", cost: "25 gp", weight: 2},
                    "Crowbar": {name: "Crowbar", cost: "2 gp", weight: 5},
                    "Fishing Tackle": {name: "Fishing Tackle", cost: "1 gp", weight: 4},
                    "Flask or Tankard": {name: "Flask or Tankard", cost: "2 cp", weight: 1, capacity: "1 pint liquid"},
                    "Grappling Hook": {name: "Grappling Hook", cost: "2 gp", weight: 4},
                    "Hammer": {name: "Hammer", cost: "1 gp", weight: 3},
                    "Hammer, Sledge": {name: "Hammer, Sledge", cost: "2 gp", weight: 10},
                    "Healer's Kit": {name: "Healer's Kit", cost: "5 gp", weight: 3, uses: 10},
                    "Holy Water (flask)": {name: "Holy Water (flask)", cost: "25 gp", weight: 1, damage: "2d6 radiant (to undead/fiends)"},
                    "Hourglass": {name: "Hourglass", cost: "25 gp", weight: 1},
                    "Hunting Trap": {name: "Hunting Trap", cost: "5 gp", weight: 25},
                    "Ink (1 ounce bottle)": {name: "Ink (1 ounce bottle)", cost: "10 gp", weight: 0},
                    "Ink Pen": {name: "Ink Pen", cost: "2 cp", weight: 0},
                    "Jug or Pitcher": {name: "Jug or Pitcher", cost: "2 cp", weight: 4, capacity: "1 gallon liquid"},
                    "Ladder (10-foot)": {name: "Ladder (10-foot)", cost: "1 sp", weight: 25},
                    "Lamp": {name: "Lamp", cost: "5 sp", weight: 1},
                    "Lantern, Bullseye": {name: "Lantern, Bullseye", cost: "10 gp", weight: 2},
                    "Lantern, Hooded": {name: "Lantern, Hooded", cost: "5 gp", weight: 2},
                    "Lock": {name: "Lock", cost: "10 gp", weight: 1},
                    "Magnifying Glass": {name: "Magnifying Glass", cost: "100 gp", weight: 0},
                    "Manacles": {name: "Manacles", cost: "2 gp", weight: 6},
                    "Mirror, Steel": {name: "Mirror, Steel", cost: "5 gp", weight: 0.5},
                    "Oil (flask)": {name: "Oil (flask)", cost: "1 sp", weight: 1},
                    "Paper (one sheet)": {name: "Paper (one sheet)", cost: "2 sp", weight: 0},
                    "Parchment (one sheet)": {name: "Parchment (one sheet)", cost: "1 sp", weight: 0},
                    "Perfume (vial)": {name: "Perfume (vial)", cost: "5 gp", weight: 0},
                    "Pick, Miner's": {name: "Pick, Miner's", cost: "2 gp", weight: 10},
                    "Piton": {name: "Piton", cost: "5 cp", weight: 0.25},
                    "Poison, Basic (vial)": {name: "Poison, Basic (vial)", cost: "100 gp", weight: 0, damage: "1d4 poison"},
                    "Pole (10-foot)": {name: "Pole (10-foot)", cost: "5 cp", weight: 7},
                    "Pot, Iron": {name: "Pot, Iron", cost: "2 gp", weight: 10},
                    "Potion of Healing": {name: "Potion of Healing", cost: "50 gp", weight: 0.5, healing: "2d4+2"},
                    "Pouch": {name: "Pouch", cost: "5 sp", weight: 1, capacity: "6 lb/1/5 cubic foot"},
                    "Quiver": {name: "Quiver", cost: "1 gp", weight: 1, capacity: "20 arrows"},
                    "Ram, Portable": {name: "Ram, Portable", cost: "4 gp", weight: 35},
                    "Rations (1 day)": {name: "Rations (1 day)", cost: "2 gp", weight: 2},
                    "Robes": {name: "Robes", cost: "1 gp", weight: 4},
                    "Rope, Hempen (50 feet)": {name: "Rope, Hempen (50 feet)", cost: "2 gp", weight: 10},
                    "Rope, Silk (50 feet)": {name: "Rope, Silk (50 feet)", cost: "10 gp", weight: 5},
                    "Sack": {name: "Sack", cost: "1 cp", weight: 0.5, capacity: "30 lb/1 cubic foot"},
                    "Scale, Merchant's": {name: "Scale, Merchant's", cost: "5 gp", weight: 3},
                    "Sealing Wax": {name: "Sealing Wax", cost: "5 sp", weight: 0},
                    "Shovel": {name: "Shovel", cost: "2 gp", weight: 5},
                    "Signal Whistle": {name: "Signal Whistle", cost: "5 cp", weight: 0},
                    "Signet Ring": {name: "Signet Ring", cost: "5 gp", weight: 0},
                    "Soap": {name: "Soap", cost: "2 cp", weight: 0},
                    "Spellbook": {name: "Spellbook", cost: "50 gp", weight: 3},
                    "Spikes, Iron (10)": {name: "Spikes, Iron (10)", cost: "1 gp", weight: 5},
                    "Spyglass": {name: "Spyglass", cost: "1,000 gp", weight: 1},
                    "Tent, Two-person": {name: "Tent, Two-person", cost: "2 gp", weight: 20},
                    "Tinderbox": {name: "Tinderbox", cost: "5 sp", weight: 1},
                    "Torch": {name: "Torch", cost: "1 cp", weight: 1, light: "bright light 20 ft, dim light 20 ft"},
                    "Vial": {name: "Vial", cost: "1 gp", weight: 0, capacity: "4 ounces liquid"},
                    "Waterskin": {name: "Waterskin", cost: "2 gp", weight: 5, capacity: "4 pints liquid"},
                    "Whetstone": {name: "Whetstone", cost: "1 cp", weight: 1}
                },
                tools: {
                    "Alchemist's Supplies": {name: "Alchemist's Supplies", cost: "50 gp", weight: 8, description: "Craft alchemical items"},
                    "Brewer's Supplies": {name: "Brewer's Supplies", cost: "20 gp", weight: 9, description: "Craft alcoholic beverages"},
                    "Calligrapher's Supplies": {name: "Calligrapher's Supplies", cost: "10 gp", weight: 5, description: "Write and design text"},
                    "Carpenter's Tools": {name: "Carpenter's Tools", cost: "8 gp", weight: 6, description: "Craft wooden objects"},
                    "Cartographer's Tools": {name: "Cartographer's Tools", cost: "15 gp", weight: 6, description: "Create maps and charts"},
                    "Cobbler's Tools": {name: "Cobbler's Tools", cost: "5 gp", weight: 5, description: "Craft and repair shoes"},
                    "Cook's Utensils": {name: "Cook's Utensils", cost: "1 gp", weight: 8, description: "Prepare meals"},
                    "Glassblower's Tools": {name: "Glassblower's Tools", cost: "30 gp", weight: 5, description: "Craft glass objects"},
                    "Jeweler's Tools": {name: "Jeweler's Tools", cost: "25 gp", weight: 2, description: "Craft jewelry and gems"},
                    "Leatherworker's Tools": {name: "Leatherworker's Tools", cost: "5 gp", weight: 5, description: "Craft leather goods"},
                    "Mason's Tools": {name: "Mason's Tools", cost: "10 gp", weight: 8, description: "Craft stone objects"},
                    "Painter's Supplies": {name: "Painter's Supplies", cost: "10 gp", weight: 5, description: "Create paintings and art"},
                    "Potter's Tools": {name: "Potter's Tools", cost: "10 gp", weight: 3, description: "Craft ceramic objects"},
                    "Smith's Tools": {name: "Smith's Tools", cost: "20 gp", weight: 8, description: "Craft metal objects"},
                    "Tinker's Tools": {name: "Tinker's Tools", cost: "50 gp", weight: 10, description: "Repair mechanical devices"},
                    "Weaver's Tools": {name: "Weaver's Tools", cost: "1 gp", weight: 5, description: "Craft cloth and fabric"},
                    "Woodcarver's Tools": {name: "Woodcarver's Tools", cost: "1 gp", weight: 5, description: "Craft wooden art objects"},
                    "Disguise Kit": {name: "Disguise Kit", cost: "25 gp", weight: 3, description: "Create disguises"},
                    "Forgery Kit": {name: "Forgery Kit", cost: "15 gp", weight: 5, description: "Create false documents"},
                    "Gaming Set (Dice)": {name: "Gaming Set (Dice)", cost: "1 sp", weight: 0, description: "Dice games and gambling"},
                    "Gaming Set (Playing Cards)": {name: "Gaming Set (Playing Cards)", cost: "5 sp", weight: 0, description: "Card games and gambling"},
                    "Gaming Set (Chess)": {name: "Gaming Set (Chess)", cost: "1 gp", weight: 0.5, description: "Strategy board games"},
                    "Herbalism Kit": {name: "Herbalism Kit", cost: "5 gp", weight: 3, description: "Create herbal remedies"},
                    "Musical Instrument (Bagpipes)": {name: "Bagpipes", cost: "30 gp", weight: 6, description: "Wind instrument"},
                    "Musical Instrument (Drum)": {name: "Drum", cost: "6 gp", weight: 3, description: "Percussion instrument"},
                    "Musical Instrument (Flute)": {name: "Flute", cost: "2 gp", weight: 1, description: "Wind instrument"},
                    "Musical Instrument (Lute)": {name: "Lute", cost: "35 gp", weight: 2, description: "String instrument"},
                    "Musical Instrument (Lyre)": {name: "Lyre", cost: "30 gp", weight: 2, description: "String instrument"},
                    "Musical Instrument (Horn)": {name: "Horn", cost: "3 gp", weight: 2, description: "Wind instrument"},
                    "Navigator's Tools": {name: "Navigator's Tools", cost: "25 gp", weight: 2, description: "Navigate and chart courses"},
                    "Poisoner's Kit": {name: "Poisoner's Kit", cost: "50 gp", weight: 2, description: "Create and apply poisons"},
                    "Thieves' Tools": {name: "Thieves' Tools", cost: "25 gp", weight: 1, description: "Pick locks and disarm traps"}
                },
                magicItems: {
                    "Potion of Healing": {name: "Potion of Healing", rarity: "Common", cost: "50 gp", weight: 0.5, description: "Regain 2d4+2 hit points"},
                    "Potion of Greater Healing": {name: "Potion of Greater Healing", rarity: "Uncommon", cost: "150 gp", weight: 0.5, description: "Regain 4d4+4 hit points"},
                    "Potion of Superior Healing": {name: "Potion of Superior Healing", rarity: "Rare", cost: "1350 gp", weight: 0.5, description: "Regain 8d4+8 hit points"},
                    "Potion of Supreme Healing": {name: "Potion of Supreme Healing", rarity: "Very Rare", cost: "13500 gp", weight: 0.5, description: "Regain 10d4+20 hit points"},
                    "Scroll of Cure Wounds": {name: "Scroll of Cure Wounds", rarity: "Common", cost: "75 gp", weight: 0, description: "Cast cure wounds as 1st level spell"},
                    "Bag of Holding": {name: "Bag of Holding", rarity: "Uncommon", cost: "4000 gp", weight: 15, description: "Extra-dimensional storage space"},
                    "Cloak of Protection": {name: "Cloak of Protection", rarity: "Uncommon", cost: "3500 gp", weight: 1, description: "+1 AC and saving throws"},
                    "Ring of Protection": {name: "Ring of Protection", rarity: "Rare", cost: "3500 gp", weight: 0, description: "+1 AC and saving throws"},
                    "Boots of Speed": {name: "Boots of Speed", rarity: "Rare", cost: "4000 gp", weight: 1, description: "Double speed for 10 minutes"},
                    "Gauntlets of Ogre Power": {name: "Gauntlets of Ogre Power", rarity: "Uncommon", cost: "8000 gp", weight: 2, description: "Strength becomes 19"},
                    "Headband of Intellect": {name: "Headband of Intellect", rarity: "Uncommon", cost: "8000 gp", weight: 1, description: "Intelligence becomes 19"}
                }
            },
            
            // Conditions Database (Complete D&D 5e)
            conditions: {
                "Blinded": {
                    name: "Blinded",
                    description: "A blinded creature can't see and automatically fails any ability check that requires sight.",
                    effects: [
                        "Attack rolls against the creature have advantage",
                        "The creature's attack rolls have disadvantage"
                    ]
                },
                "Charmed": {
                    name: "Charmed", 
                    description: "A charmed creature can't attack the charmer or target the charmer with harmful abilities or magical effects.",
                    effects: [
                        "The charmer has advantage on any ability check to interact socially with the creature"
                    ]
                },
                "Deafened": {
                    name: "Deafened",
                    description: "A deafened creature can't hear and automatically fails any ability check that requires hearing.",
                    effects: []
                },
                "Exhaustion": {
                    name: "Exhaustion",
                    description: "Some special abilities and environmental hazards, such as starvation and the long-term effects of freezing or scorching temperatures, can lead to a special condition called exhaustion.",
                    levels: [
                        "1: Disadvantage on ability checks",
                        "2: Speed halved", 
                        "3: Disadvantage on attack rolls and saving throws",
                        "4: Hit point maximum halved",
                        "5: Speed reduced to 0",
                        "6: Death"
                    ]
                },
                "Frightened": {
                    name: "Frightened",
                    description: "A frightened creature has disadvantage on ability checks and attack rolls while the source of its fear is within line of sight.",
                    effects: [
                        "The creature can't willingly move closer to the source of its fear"
                    ]
                },
                "Grappled": {
                    name: "Grappled",
                    description: "A grappled creature's speed becomes 0, and it can't benefit from any bonus to its speed.",
                    effects: [
                        "The condition ends if the grappler is incapacitated",
                        "The condition also ends if an effect removes the grappled creature from the reach of the grappler"
                    ]
                },
                "Incapacitated": {
                    name: "Incapacitated", 
                    description: "An incapacitated creature can't take actions or reactions.",
                    effects: []
                },
                "Invisible": {
                    name: "Invisible",
                    description: "An invisible creature is impossible to see without the aid of magic or a special sense.",
                    effects: [
                        "The creature is heavily obscured for the purpose of hiding",
                        "Attack rolls against the creature have disadvantage",
                        "The creature's attack rolls have advantage"
                    ]
                },
                "Paralyzed": {
                    name: "Paralyzed",
                    description: "A paralyzed creature is incapacitated and can't move or speak.",
                    effects: [
                        "The creature automatically fails Strength and Dexterity saving throws",
                        "Attack rolls against the creature have advantage",
                        "Any attack that hits the creature is a critical hit if the attacker is within 5 feet"
                    ]
                },
                "Petrified": {
                    name: "Petrified",
                    description: "A petrified creature is transformed, along with any nonmagical object it is wearing or carrying, into a solid inanimate substance (usually stone).",
                    effects: [
                        "Its weight increases by a factor of ten, and it ceases aging",
                        "The creature is incapacitated, can't move or speak, and is unaware of its surroundings",
                        "Attack rolls against the creature have advantage",
                        "The creature automatically fails Strength and Dexterity saving throws",
                        "The creature has resistance to all damage",
                        "The creature is immune to poison and disease"
                    ]
                },
                "Poisoned": {
                    name: "Poisoned",
                    description: "A poisoned creature has disadvantage on attack rolls and ability checks.",
                    effects: []
                },
                "Prone": {
                    name: "Prone",
                    description: "A prone creature's only movement option is to crawl, unless it stands up and thereby ends the condition.",
                    effects: [
                        "The creature has disadvantage on attack rolls",
                        "An attack roll against the creature has advantage if the attacker is within 5 feet, otherwise disadvantage"
                    ]
                },
                "Restrained": {
                    name: "Restrained",
                    description: "A restrained creature's speed becomes 0, and it can't benefit from any bonus to its speed.",
                    effects: [
                        "Attack rolls against the creature have advantage",
                        "The creature's attack rolls have disadvantage", 
                        "The creature has disadvantage on Dexterity saving throws"
                    ]
                },
                "Stunned": {
                    name: "Stunned",
                    description: "A stunned creature is incapacitated, can't move, and can speak only falteringly.",
                    effects: [
                        "The creature automatically fails Strength and Dexterity saving throws",
                        "Attack rolls against the creature have advantage"
                    ]
                },
                "Unconscious": {
                    name: "Unconscious",
                    description: "An unconscious creature is incapacitated, can't move or speak, and is unaware of its surroundings.",
                    effects: [
                        "The creature drops whatever it's holding and falls prone",
                        "The creature automatically fails Strength and Dexterity saving throws",
                        "Attack rolls against the creature have advantage",
                        "Any attack that hits the creature is a critical hit if the attacker is within 5 feet"
                    ]
                }
            },
            
            // Combat Actions Database
            combatActions: {
                "Attack": {
                    name: "Attack",
                    type: "Action",
                    description: "Make one melee or ranged attack with a weapon.",
                    details: "Roll 1d20 + ability modifier + proficiency bonus (if proficient) vs target AC. On hit, roll weapon damage + ability modifier."
                },
                "Cast a Spell": {
                    name: "Cast a Spell",
                    type: "Action/Bonus Action/Reaction",
                    description: "Cast a spell with a casting time of 1 action, bonus action, or reaction.",
                    details: "Follow the spell's specific rules for range, components, and effects."
                },
                "Dash": {
                    name: "Dash",
                    type: "Action",
                    description: "Gain extra movement equal to your speed.",
                    details: "You can move up to twice your speed this turn."
                },
                "Disengage": {
                    name: "Disengage",
                    type: "Action",
                    description: "Your movement doesn't provoke opportunity attacks for the rest of the turn.",
                    details: "Move away from enemies without triggering attacks of opportunity."
                },
                "Dodge": {
                    name: "Dodge",
                    type: "Action", 
                    description: "Focus entirely on avoiding attacks.",
                    details: "Until the start of your next turn, attack rolls against you have disadvantage, and you make Dexterity saving throws with advantage."
                },
                "Help": {
                    name: "Help",
                    type: "Action",
                    description: "Aid another creature in completing a task.",
                    details: "Give advantage on the next ability check or attack roll against a creature within 5 feet of you."
                },
                "Hide": {
                    name: "Hide",
                    type: "Action",
                    description: "Make a Dexterity (Stealth) check to hide.",
                    details: "You must have cover or be heavily obscured. Success makes you hidden from creatures that can't see you."
                },
                "Ready": {
                    name: "Ready",
                    type: "Action",
                    description: "Prepare an action to trigger on a specific condition.",
                    details: "Choose an action and a trigger. When the trigger occurs, you can use your reaction to perform the readied action."
                },
                "Search": {
                    name: "Search",
                    type: "Action",
                    description: "Make a Wisdom (Perception) or Intelligence (Investigation) check to find something.",
                    details: "Look for hidden objects, creatures, or clues in your environment."
                },
                "Use an Object": {
                    name: "Use an Object",
                    type: "Action",
                    description: "Interact with an object in your environment.",
                    details: "Draw a weapon, open a door, drink a potion, or similar object interaction."
                },
                "Grapple": {
                    name: "Grapple",
                    type: "Special Attack",
                    description: "Attempt to grab a creature.",
                    details: "Make a Strength (Athletics) check contested by the target's Strength (Athletics) or Dexterity (Acrobatics). Success grapples the target."
                },
                "Shove": {
                    name: "Shove",
                    type: "Special Attack", 
                    description: "Push a creature or knock it prone.",
                    details: "Make a Strength (Athletics) check contested by target's Strength (Athletics) or Dexterity (Acrobatics). Success pushes 5 feet or knocks prone."
                },
                "Two-Weapon Fighting": {
                    name: "Two-Weapon Fighting",
                    type: "Bonus Action",
                    description: "Attack with a light weapon in your off hand.",
                    details: "When you attack with a light weapon, you can use a bonus action to attack with a different light weapon in your other hand (no ability modifier to damage unless negative)."
                },
                "Opportunity Attack": {
                    name: "Opportunity Attack",
                    type: "Reaction",
                    description: "Attack a creature that leaves your reach.",
                    details: "When a hostile creature moves out of your reach, you can use your reaction to make one melee attack against it."
                }
            },
            
            // Backgrounds Database
            backgrounds: {
                "Acolyte": {
                    name: "Acolyte",
                    description: "You have spent your life in the service of a temple to a specific god or pantheon of gods.",
                    skillProficiencies: ["Insight", "Religion"],
                    languages: 2,
                    equipment: ["Holy symbol", "Prayer book", "Incense", "Vestments", "Common clothes", "15 gp"],
                    feature: {name: "Shelter of the Faithful", description: "You can perform religious ceremonies and receive aid from temples."}
                },
                "Criminal": {
                    name: "Criminal",
                    description: "You are an experienced criminal with a history of breaking the law.",
                    skillProficiencies: ["Deception", "Stealth"],
                    toolProficiencies: ["Thieves' Tools", "Gaming Set"],
                    equipment: ["Crowbar", "Dark clothes with hood", "15 gp"],
                    feature: {name: "Criminal Contact", description: "You have a reliable contact who acts as your liaison to criminal networks."}
                },
                "Folk Hero": {
                    name: "Folk Hero",
                    description: "You come from humble origins, but are destined for much more.",
                    skillProficiencies: ["Animal Handling", "Survival"],
                    toolProficiencies: ["Artisan's Tools", "Vehicles (Land)"],
                    equipment: ["Artisan's tools", "Shovel", "Set of artisan clothes", "10 gp"],
                    feature: {name: "Rustic Hospitality", description: "Common folk will shelter and hide you if needed."}
                },
                "Noble": {
                    name: "Noble",
                    description: "You understand wealth, power, and privilege.",
                    skillProficiencies: ["History", "Persuasion"],
                    toolProficiencies: ["Gaming Set"],
                    languages: 1,
                    equipment: ["Fine clothes", "Signet ring", "Scroll of pedigree", "25 gp"],
                    feature: {name: "Position of Privilege", description: "You are welcome in high society and can secure audiences with nobles."}
                },
                "Sage": {
                    name: "Sage",
                    description: "You spent years learning the lore of the multiverse.",
                    skillProficiencies: ["Arcana", "History"],
                    languages: 2,
                    equipment: ["Ink and quill", "Small knife", "Scholar's robes", "10 gp"],
                    feature: {name: "Researcher", description: "You know where to find information and can access libraries."}
                },
                "Soldier": {
                    name: "Soldier",
                    description: "War has been your life for as long as you care to remember.",
                    skillProficiencies: ["Athletics", "Intimidation"],
                    toolProficiencies: ["Gaming Set", "Vehicles (Land)"],
                    equipment: ["Insignia of rank", "Trophy", "Common clothes", "10 gp"],
                    feature: {name: "Military Rank", description: "You have a military rank and can invoke authority over soldiers."}
                }
            },
            
            // Random Generators Database
            generators: {
                treasures: {
                    individual: {
                        cr0_4: [{coins: "5d6 cp"}, {coins: "4d6 cp"}, {coins: "3d6 cp"}, {coins: "2d6 cp"}],
                        cr5_10: [{coins: "2d6 × 100 cp, 2d4 × 10 sp"}, {coins: "2d6 × 10 sp, 1d6 × 10 gp"}],
                        cr11_16: [{coins: "4d6 × 100 sp, 1d6 × 100 gp"}, {coins: "2d6 × 100 gp, 1d6 × 10 pp"}],
                        cr17_plus: [{coins: "2d6 × 1000 gp, 8d6 × 100 pp"}]
                    },
                    magic_items: {
                        common: ["Potion of Healing", "Spell Scroll (Cantrip)", "+1 Ammunition (10)"],
                        uncommon: ["Bag of Holding", "Cloak of Elvenkind", "Boots of Speed", "Ring of Protection"],
                        rare: ["Flame Tongue", "Ring of Regeneration", "Cloak of Displacement"],
                        very_rare: ["Belt of Storm Giant Strength", "Ring of Invisibility"],
                        legendary: ["Holy Avenger", "Ring of Three Wishes"]
                    }
                },
                npcs: {
                    names: {
                        human_male: ["Aerdel", "Beiro", "Carric", "Drannor", "Enna", "Galinndan", "Hadarai", "Immeral", "Ivellios", "Korfel"],
                        human_female: ["Adrie", "Birel", "Caelynn", "Dara", "Enna", "Galinndan", "Halimath", "Immeral", "Ivellios", "Korfel"],
                        elf_male: ["Adran", "Aelar", "Aramil", "Arannis", "Berris", "Dayereth", "Enna", "Galinndan", "Hadarai", "Halimath"],
                        elf_female: ["Adrie", "Althaea", "Anastrianna", "Andraste", "Antinua", "Bethrynna", "Birel", "Caelynn", "Dara", "Enna"],
                        dwarf_male: ["Adrik", "Alberich", "Baern", "Barendd", "Brottor", "Bruenor", "Dain", "Darrak", "Delg", "Eberk"],
                        dwarf_female: ["Amber", "Bardryn", "Diesa", "Eldeth", "Gunnloda", "Gusta", "Helja", "Hlin", "Kathra", "Kristryd"]
                    },
                    personalities: [
                        "Argumentative", "Arrogant", "Blustering", "Rude", "Curious", "Friendly", "Honest", "Hot tempered",
                        "Irritable", "Ponderous", "Quiet", "Suspicious", "Brave", "Cowardly", "Lazy", "Nervous"
                    ],
                    ideals: [
                        "Beauty", "Charity", "Greater good", "Life", "Respect", "Self-sacrifice", "Domination", "Greed",
                        "Might", "Pain", "Revenge", "Retribution", "Balance", "Knowledge", "Logic", "Tradition"
                    ],
                    flaws: [
                        "Forbidden love", "Enjoys decadent pleasures", "Arrogance", "Envies another", "Overpowering greed",
                        "Prone to rage", "Has a powerful enemy", "Specific phobia", "Shameful past", "Secret crime"
                    ]
                },
                environments: {
                    forest: ["Ancient oak grove", "Misty woodland path", "Babbling brook", "Abandoned ranger station", "Fairy ring of mushrooms"],
                    mountain: ["Rocky cliff face", "Hidden cave entrance", "Mountain peak shrine", "Narrow mountain pass", "Avalanche zone"],
                    dungeon: ["Torch-lit corridor", "Ancient stone chamber", "Flooded basement", "Collapsed ceiling", "Secret passage"],
                    city: ["Bustling marketplace", "Noble's district", "Seedy tavern", "Thieves' guild hideout", "Temple district"],
                    desert: ["Sand dune oasis", "Buried ruins", "Merchant caravan", "Nomad encampment", "Mirage pool"]
                }
            },
            
            // Conditions Database
            conditions: {
                "Blinded": {
                    name: "Blinded",
                    description: "A blinded creature can't see and automatically fails any ability check that requires sight. Attack rolls against the creature have advantage, and the creature's attack rolls have disadvantage."
                },
                "Charmed": {
                    name: "Charmed",
                    description: "A charmed creature can't attack the charmer or target the charmer with harmful abilities or magical effects. The charmer has advantage on any ability check to interact socially with the creature."
                },
                "Poisoned": {
                    name: "Poisoned",
                    description: "A poisoned creature has disadvantage on attack rolls and ability checks."
                }
            }
        };
        
        // ===== GLOBAL GAME STATE =====
        let gameState = {
            currentSession: {
                party: [],
                activeEncounter: null,
                currentMap: null,
                time: {day: 1, hour: 8},
                weather: "Clear"
            },
            combat: {
                active: false,
                round: 0,
                turn: 0,
                initiatives: [],
                participants: []
            },
            characters: JSON.parse(localStorage.getItem('dnd_characters') || '[]'),
            maps: JSON.parse(localStorage.getItem('dnd_maps') || '[]'),
            campaigns: JSON.parse(localStorage.getItem('dnd_campaigns') || '[]')
        };
        
        // ===== UTILITY FUNCTIONS =====
        function rollDice(sides, count = 1, modifier = 0) {
            let total = modifier;
            let rolls = [];
            for (let i = 0; i < count; i++) {
                const roll = Math.floor(Math.random() * sides) + 1;
                rolls.push(roll);
                total += roll;
            }
            return {total, rolls, modifier};
        }
        
        function rollAdvantage(sides) {
            const roll1 = rollDice(sides);
            const roll2 = rollDice(sides);
            return roll1.total > roll2.total ? roll1 : roll2;
        }
        
        function rollDisadvantage(sides) {
            const roll1 = rollDice(sides);
            const roll2 = rollDice(sides);
            return roll1.total < roll2.total ? roll1 : roll2;
        }
        
        function calculateModifier(score) {
            return Math.floor((score - 10) / 2);
        }
        
        function saveData() {
            localStorage.setItem('dnd_characters', JSON.stringify(gameState.characters));
            localStorage.setItem('dnd_maps', JSON.stringify(gameState.maps));
            localStorage.setItem('dnd_campaigns', JSON.stringify(gameState.campaigns));
        }
        
        // ===== TAB MANAGEMENT =====
        function showTab(tabName) {
            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            const content = document.getElementById(`content-${tabName}`);
            if (content) {
                content.classList.add('active');
            }
            
            // Add active class to selected tab button
            const button = document.getElementById(`tab-${tabName}`);
            if (button) {
                button.classList.add('active');
            }
        }
        
        // ===== COMPREHENSIVE ENCOUNTER BUILDER SYSTEM =====
        class EncounterBuilder {
            constructor() {
                this.currentEncounter = {
                    name: '',
                    description: '',
                    monsters: [],
                    environment: 'dungeon',
                    difficulty: 'medium',
                    partySize: 4,
                    partyLevel: 1,
                    totalXP: 0,
                    adjustedXP: 0,
                    treasure: []
                };
                
                // CR calculation thresholds per character level
                this.xpThresholds = {
                    1: { easy: 25, medium: 50, hard: 75, deadly: 100 },
                    2: { easy: 50, medium: 100, hard: 150, deadly: 200 },
                    3: { easy: 75, medium: 150, hard: 225, deadly: 400 },
                    4: { easy: 125, medium: 250, hard: 375, deadly: 500 },
                    5: { easy: 250, medium: 500, hard: 750, deadly: 1100 },
                    6: { easy: 300, medium: 600, hard: 900, deadly: 1400 },
                    7: { easy: 350, medium: 750, hard: 1100, deadly: 1700 },
                    8: { easy: 450, medium: 900, hard: 1400, deadly: 2100 },
                    9: { easy: 550, medium: 1100, hard: 1600, deadly: 2400 },
                    10: { easy: 600, medium: 1200, hard: 1900, deadly: 2800 },
                    11: { easy: 800, medium: 1600, hard: 2400, deadly: 3600 },
                    12: { easy: 1000, medium: 2000, hard: 3000, deadly: 4500 },
                    13: { easy: 1100, medium: 2200, hard: 3400, deadly: 5100 },
                    14: { easy: 1250, medium: 2500, hard: 3800, deadly: 5700 },
                    15: { easy: 1400, medium: 2800, hard: 4300, deadly: 6400 },
                    16: { easy: 1600, medium: 3200, hard: 4800, deadly: 7200 },
                    17: { easy: 2000, medium: 3900, hard: 5900, deadly: 8800 },
                    18: { easy: 2100, medium: 4200, hard: 6300, deadly: 9500 },
                    19: { easy: 2400, medium: 4900, hard: 7300, deadly: 10900 },
                    20: { easy: 2800, medium: 5700, hard: 8500, deadly: 12700 }
                };
                
                // Monster XP values by CR
                this.monsterXP = {
                    '0': 10, '1/8': 25, '1/4': 50, '1/2': 100,
                    '1': 200, '2': 450, '3': 700, '4': 1100, '5': 1800,
                    '6': 2300, '7': 2900, '8': 3900, '9': 5000, '10': 5900,
                    '11': 7200, '12': 8400, '13': 10000, '14': 11500, '15': 13000,
                    '16': 15000, '17': 18000, '18': 20000, '19': 22000, '20': 25000,
                    '21': 33000, '22': 41000, '23': 50000, '24': 62000, '25': 75000,
                    '26': 90000, '27': 105000, '28': 120000, '29': 135000, '30': 155000
                };
                
                // Encounter multipliers based on number of monsters (DMG 5e rules)
                this.encounterMultipliers = {
                    1: 1.0,
                    2: 1.5,
                    3: 2.0, 4: 2.0, 5: 2.0, 6: 2.0,        // 3-6 creatures: 2×
                    7: 2.5, 8: 2.5, 9: 2.5, 10: 2.5,       // 7-10 creatures: 2.5×
                    11: 3.0, 12: 3.0, 13: 3.0, 14: 3.0,    // 11-14 creatures: 3×
                    15: 4.0                                  // 15+ creatures: 4×
                };
                
                // Treasure tables by CR range
                this.treasureTables = {
                    'CR 0-4': {
                        coins: { copper: [0, 6, 6], silver: [0, 3, 6], gold: [0, 2, 6] },
                        items: ['Potion of Healing', 'Silvered Dagger', 'Spell Scroll (1st level)']
                    },
                    'CR 5-10': {
                        coins: { silver: [2, 6, 100], gold: [2, 4, 10], platinum: [0, 3, 10] },
                        items: ['Potion of Greater Healing', '+1 Weapon', 'Spell Scroll (2nd level)', 'Bag of Holding']
                    },
                    'CR 11-16': {
                        coins: { gold: [4, 6, 100], platinum: [1, 6, 10] },
                        items: ['+2 Weapon', '+1 Armor', 'Spell Scroll (3rd level)', 'Ring of Protection']
                    },
                    'CR 17+': {
                        coins: { gold: [12, 6, 100], platinum: [8, 6, 100] },
                        items: ['+3 Weapon', '+2 Armor', 'Legendary Magic Item', 'Spell Scroll (5th level)']
                    }
                };
            }
            
            // ===== ENCOUNTER CREATION =====
            createEncounter(name, description, environment = 'dungeon') {
                this.currentEncounter = {
                    name: name,
                    description: description,
                    monsters: [],
                    environment: environment,
                    difficulty: 'medium',
                    partySize: 4,
                    partyLevel: 1,
                    totalXP: 0,
                    adjustedXP: 0,
                    treasure: []
                };
                
                return this.currentEncounter;
            }
            
            setPartyParameters(size, level) {
                this.currentEncounter.partySize = size;
                this.currentEncounter.partyLevel = level;
                this.updateEncounterDifficulty();
            }
            
            // ===== MONSTER MANAGEMENT =====
            addMonster(monster, quantity = 1) {
                for (let i = 0; i < quantity; i++) {
                    const monsterInstance = {
                        ...monster,
                        id: Date.now() + Math.random(),
                        name: quantity > 1 ? `${monster.name} ${i + 1}` : monster.name,
                        hp: monster.hp,
                        maxHp: monster.hp,
                        initiative: 0
                    };
                    
                    this.currentEncounter.monsters.push(monsterInstance);
                }
                
                this.updateEncounterDifficulty();
                return this.currentEncounter;
            }
            
            removeMonster(monsterId) {
                this.currentEncounter.monsters = this.currentEncounter.monsters.filter(m => m.id !== monsterId);
                this.updateEncounterDifficulty();
            }
            
            clearMonsters() {
                this.currentEncounter.monsters = [];
                this.updateEncounterDifficulty();
            }
            
            // ===== CR CALCULATION SYSTEM =====
            calculateEncounterXP() {
                // Calculate total monster XP
                let totalXP = 0;
                this.currentEncounter.monsters.forEach(monster => {
                    const cr = monster.challengeRating || monster.cr || '0';
                    totalXP += this.monsterXP[cr] || 0;
                });
                
                this.currentEncounter.totalXP = totalXP;
                
                // Apply encounter multiplier based on number of monsters
                const monsterCount = this.currentEncounter.monsters.length;
                const multiplier = this.getEncounterMultiplier(monsterCount);
                this.currentEncounter.adjustedXP = Math.floor(totalXP * multiplier);
                
                return {
                    totalXP: this.currentEncounter.totalXP,
                    adjustedXP: this.currentEncounter.adjustedXP,
                    multiplier: multiplier
                };
            }
            
            getEncounterMultiplier(monsterCount) {
                // DMG 5e encounter multiplier rules
                if (monsterCount >= 15) {
                    return 4.0; // 15+ creatures: 4× (DMG 5e rule)
                }
                return this.encounterMultipliers[monsterCount] || 1.0;
            }
            
            updateEncounterDifficulty() {
                const xpData = this.calculateEncounterXP();
                const thresholds = this.calculatePartyThresholds();
                
                if (xpData.adjustedXP < thresholds.easy) {
                    this.currentEncounter.difficulty = 'trivial';
                } else if (xpData.adjustedXP < thresholds.medium) {
                    this.currentEncounter.difficulty = 'easy';
                } else if (xpData.adjustedXP < thresholds.hard) {
                    this.currentEncounter.difficulty = 'medium';
                } else if (xpData.adjustedXP < thresholds.deadly) {
                    this.currentEncounter.difficulty = 'hard';
                } else {
                    this.currentEncounter.difficulty = 'deadly';
                }
                
                return this.currentEncounter.difficulty;
            }
            
            calculatePartyThresholds() {
                const level = this.currentEncounter.partyLevel;
                const size = this.currentEncounter.partySize;
                const thresholds = this.xpThresholds[level] || this.xpThresholds[1];
                
                return {
                    easy: thresholds.easy * size,
                    medium: thresholds.medium * size,
                    hard: thresholds.hard * size,
                    deadly: thresholds.deadly * size
                };
            }
            
            // ===== ENCOUNTER BALANCING =====
            generateBalancedEncounter(difficulty = 'medium', environment = 'dungeon') {
                this.currentEncounter.difficulty = difficulty;
                this.currentEncounter.environment = environment;
                
                const thresholds = this.calculatePartyThresholds();
                const targetXP = thresholds[difficulty];
                
                // Select appropriate monsters from database
                const availableMonsters = this.getMonstersByEnvironment(environment);
                const selectedMonsters = this.selectMonstersForXP(availableMonsters, targetXP);
                
                // Add selected monsters to encounter
                this.clearMonsters();
                selectedMonsters.forEach(monster => {
                    this.addMonster(monster.monster, monster.quantity);
                });
                
                // Generate treasure
                this.generateTreasure();
                
                return this.currentEncounter;
            }
            
            getMonstersByEnvironment(environment) {
                // Filter monsters based on environment
                const allMonsters = Object.values(DND_DATA.monsters);
                return allMonsters.filter(monster => {
                    if (!monster.environment) return true; // Include monsters without environment specified
                    return monster.environment.includes(environment);
                });
            }
            
            selectMonstersForXP(availableMonsters, targetXP) {
                const selected = [];
                let remainingXP = targetXP;
                let attempts = 0;
                const maxAttempts = 50;
                
                while (remainingXP > 50 && attempts < maxAttempts) {
                    attempts++;
                    
                    // Select random monster that fits within remaining XP budget
                    const suitableMonsters = availableMonsters.filter(monster => {
                        const cr = monster.challengeRating || monster.cr || '0';
                        const monsterXP = this.monsterXP[cr] || 0;
                        return monsterXP <= remainingXP * 0.8; // Leave room for multipliers
                    });
                    
                    if (suitableMonsters.length === 0) break;
                    
                    const randomMonster = suitableMonsters[Math.floor(Math.random() * suitableMonsters.length)];
                    const cr = randomMonster.challengeRating || randomMonster.cr || '0';
                    const monsterXP = this.monsterXP[cr] || 0;
                    
                    // Determine quantity (sometimes add multiple weaker monsters)
                    let quantity = 1;
                    if (monsterXP < targetXP * 0.3) {
                        quantity = Math.min(4, Math.floor(remainingXP / monsterXP));
                    }
                    
                    selected.push({ monster: randomMonster, quantity: quantity });
                    remainingXP -= monsterXP * quantity;
                }
                
                return selected;
            }
            
            // ===== TREASURE GENERATION =====
            generateTreasure() {
                const maxCR = Math.max(...this.currentEncounter.monsters.map(m => {
                    const cr = m.challengeRating || m.cr || '0';
                    return this.crToNumber(cr);
                }));
                
                let treasureCategory;
                if (maxCR <= 4) treasureCategory = 'CR 0-4';
                else if (maxCR <= 10) treasureCategory = 'CR 5-10';
                else if (maxCR <= 16) treasureCategory = 'CR 11-16';
                else treasureCategory = 'CR 17+';
                
                const treasureTable = this.treasureTables[treasureCategory];
                this.currentEncounter.treasure = [];
                
                // Generate coins
                Object.entries(treasureTable.coins).forEach(([coinType, dice]) => {
                    const amount = this.rollDice(dice[0], dice[1], dice[2]);
                    if (amount > 0) {
                        this.currentEncounter.treasure.push({
                            type: 'currency',
                            name: `${amount} ${coinType}`,
                            value: amount
                        });
                    }
                });
                
                // Generate magic items (chance based on difficulty)
                const itemChance = this.currentEncounter.difficulty === 'deadly' ? 0.8 : 
                                  this.currentEncounter.difficulty === 'hard' ? 0.6 :
                                  this.currentEncounter.difficulty === 'medium' ? 0.4 : 0.2;
                
                if (Math.random() < itemChance) {
                    const randomItem = treasureTable.items[Math.floor(Math.random() * treasureTable.items.length)];
                    this.currentEncounter.treasure.push({
                        type: 'item',
                        name: randomItem,
                        rarity: this.getItemRarity(randomItem)
                    });
                }
                
                return this.currentEncounter.treasure;
            }
            
            crToNumber(cr) {
                if (typeof cr === 'number') return cr;
                if (cr === '1/8') return 0.125;
                if (cr === '1/4') return 0.25;
                if (cr === '1/2') return 0.5;
                return parseInt(cr) || 0;
            }
            
            rollDice(num, sides, multiplier = 1) {
                let total = 0;
                for (let i = 0; i < num; i++) {
                    total += Math.floor(Math.random() * sides) + 1;
                }
                return total * multiplier;
            }
            
            getItemRarity(itemName) {
                if (itemName.includes('+3') || itemName.includes('Legendary')) return 'legendary';
                if (itemName.includes('+2') || itemName.includes('Ring')) return 'rare';
                if (itemName.includes('+1') || itemName.includes('Bag')) return 'uncommon';
                return 'common';
            }
            
            // ===== ENCOUNTER MANAGEMENT =====
            saveEncounter() {
                const saved = {
                    ...this.currentEncounter,
                    timestamp: new Date().toISOString(),
                    id: Date.now()
                };
                
                // Save to localStorage
                const savedEncounters = JSON.parse(localStorage.getItem('dnd_encounters') || '[]');
                savedEncounters.push(saved);
                localStorage.setItem('dnd_encounters', JSON.stringify(savedEncounters));
                
                return saved;
            }
            
            loadEncounter(encounterId) {
                const savedEncounters = JSON.parse(localStorage.getItem('dnd_encounters') || '[]');
                const encounter = savedEncounters.find(e => e.id === encounterId);
                
                if (encounter) {
                    this.currentEncounter = encounter;
                    return encounter;
                }
                return null;
            }
            
            getSavedEncounters() {
                return JSON.parse(localStorage.getItem('dnd_encounters') || '[]');
            }
            
            // ===== COMBAT INTEGRATION =====
            startCombat() {
                if (!window.combat) {
                    console.error('Combat manager not available');
                    return false;
                }
                
                // Add all monsters to combat
                this.currentEncounter.monsters.forEach(monster => {
                    combat.addParticipant(monster, 0, false);
                });
                
                // Start combat
                combat.isActive = true;
                combat.round = 1;
                combat.currentTurn = 0;
                
                // Update UI
                combat.updateUI();
                
                return true;
            }
            
            // ===== ENCOUNTER ANALYSIS =====
            analyzeEncounter() {
                const xpData = this.calculateEncounterXP();
                const thresholds = this.calculatePartyThresholds();
                
                return {
                    difficulty: this.currentEncounter.difficulty,
                    totalXP: xpData.totalXP,
                    adjustedXP: xpData.adjustedXP,
                    thresholds: thresholds,
                    monsterCount: this.currentEncounter.monsters.length,
                    averageMonsterCR: this.getAverageMonsterCR(),
                    recommendations: this.getEncounterRecommendations()
                };
            }
            
            getAverageMonsterCR() {
                if (this.currentEncounter.monsters.length === 0) return 0;
                
                const totalCR = this.currentEncounter.monsters.reduce((sum, monster) => {
                    return sum + this.crToNumber(monster.challengeRating || monster.cr || '0');
                }, 0);
                
                return totalCR / this.currentEncounter.monsters.length;
            }
            
            getEncounterRecommendations() {
                const recommendations = [];
                const analysis = this.analyzeEncounter();
                
                if (analysis.difficulty === 'trivial') {
                    recommendations.push('Consider adding more monsters or increasing their CR for a more challenging encounter.');
                }
                
                if (analysis.difficulty === 'deadly') {
                    recommendations.push('This is a very dangerous encounter. Consider reducing monster count or CR.');
                }
                
                if (analysis.monsterCount > 8) {
                    recommendations.push('Large numbers of monsters can slow down combat. Consider using fewer, stronger monsters.');
                }
                
                if (this.currentEncounter.treasure.length === 0) {
                    recommendations.push('Consider adding treasure rewards for completing this encounter.');
                }
                
                return recommendations;
            }
        }
        
        // ===== COMPREHENSIVE ABILITY CHECK SYSTEM =====
        class AbilityCheckSystem {
            constructor() {
                this.abilities = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
                this.skills = {
                    'athletics': 'strength',
                    'acrobatics': 'dexterity',
                    'sleight_of_hand': 'dexterity',
                    'stealth': 'dexterity',
                    'arcana': 'intelligence',
                    'history': 'intelligence',
                    'investigation': 'intelligence',
                    'nature': 'intelligence',
                    'religion': 'intelligence',
                    'animal_handling': 'wisdom',
                    'insight': 'wisdom',
                    'medicine': 'wisdom',
                    'perception': 'wisdom',
                    'survival': 'wisdom',
                    'deception': 'charisma',
                    'intimidation': 'charisma',
                    'performance': 'charisma',
                    'persuasion': 'charisma'
                };
                
                this.skillDisplayNames = {
                    'athletics': 'Athletics',
                    'acrobatics': 'Acrobatics',
                    'sleight_of_hand': 'Sleight of Hand',
                    'stealth': 'Stealth',
                    'arcana': 'Arcana',
                    'history': 'History',
                    'investigation': 'Investigation',
                    'nature': 'Nature',
                    'religion': 'Religion',
                    'animal_handling': 'Animal Handling',
                    'insight': 'Insight',
                    'medicine': 'Medicine',
                    'perception': 'Perception',
                    'survival': 'Survival',
                    'deception': 'Deception',
                    'intimidation': 'Intimidation',
                    'performance': 'Performance',
                    'persuasion': 'Persuasion'
                };
                
                this.checkHistory = [];
                this.activeChecks = [];
                this.passiveScores = {};
            }
            
            // ===== ABILITY SCORE CALCULATIONS =====
            getAbilityModifier(score) {
                return Math.floor((score - 10) / 2);
            }
            
            getProficiencyBonus(level) {
                return Math.ceil(level / 4) + 1;
            }
            
            calculateSkillModifier(character, skill, expertise = false) {
                const ability = this.skills[skill];
                const abilityScore = character[ability] || 10;
                const abilityMod = this.getAbilityModifier(abilityScore);
                let bonus = abilityMod;
                
                // Add proficiency bonus if proficient
                if (character.proficiencies && character.proficiencies.includes(skill)) {
                    const profBonus = this.getProficiencyBonus(character.level || 1);
                    bonus += expertise ? profBonus * 2 : profBonus;
                }
                
                // Add other bonuses (magic items, blessings, etc.)
                if (character.skillBonuses && character.skillBonuses[skill]) {
                    bonus += character.skillBonuses[skill];
                }
                
                return bonus;
            }
            
            // ===== PASSIVE ABILITY CHECKS =====
            calculatePassiveScore(character, skill, variant = null) {
                const skillMod = this.calculateSkillModifier(character, skill, character.expertise?.includes(skill));
                let passiveScore = 10 + skillMod;
                
                // Apply variants
                if (variant === 'advantage') {
                    passiveScore += 5;
                } else if (variant === 'disadvantage') {
                    passiveScore -= 5;
                }
                
                // Special passive bonuses
                if (character.passiveBonuses && character.passiveBonuses[skill]) {
                    passiveScore += character.passiveBonuses[skill];
                }
                
                return passiveScore;
            }
            
            updatePassiveScores(character) {
                this.passiveScores[character.id] = {};
                Object.keys(this.skills).forEach(skill => {
                    this.passiveScores[character.id][skill] = this.calculatePassiveScore(character, skill);
                });
                
                return this.passiveScores[character.id];
            }
            
            // ===== STANDARD ABILITY CHECKS =====
            rollAbilityCheck(character, ability, advantage = false, disadvantage = false, bonus = 0) {
                const abilityScore = character[ability] || 10;
                const abilityMod = this.getAbilityModifier(abilityScore);
                const totalBonus = abilityMod + bonus;
                
                const roll = this.rollWithAdvantage(advantage, disadvantage);
                const total = roll.total + totalBonus;
                
                const result = {
                    type: 'ability_check',
                    character: character.name,
                    ability: ability,
                    roll: roll,
                    modifier: totalBonus,
                    total: total,
                    advantage: advantage,
                    disadvantage: disadvantage,
                    timestamp: new Date().toISOString()
                };
                
                this.checkHistory.push(result);
                return result;
            }
            
            rollSkillCheck(character, skill, advantage = false, disadvantage = false, bonus = 0, variantAbility = null) {
                const ability = variantAbility || this.skills[skill];
                const skillMod = this.calculateSkillModifier(character, skill, character.expertise?.includes(skill));
                const totalBonus = skillMod + bonus;
                
                const roll = this.rollWithAdvantage(advantage, disadvantage);
                const total = roll.total + totalBonus;
                
                const result = {
                    type: 'skill_check',
                    character: character.name,
                    skill: skill,
                    ability: ability,
                    roll: roll,
                    modifier: totalBonus,
                    total: total,
                    advantage: advantage,
                    disadvantage: disadvantage,
                    variantAbility: variantAbility,
                    timestamp: new Date().toISOString()
                };
                
                this.checkHistory.push(result);
                return result;
            }
            
            rollWithAdvantage(advantage = false, disadvantage = false) {
                const roll1 = Math.floor(Math.random() * 20) + 1;
                const roll2 = Math.floor(Math.random() * 20) + 1;
                
                let result = {
                    dice: [roll1],
                    total: roll1
                };
                
                if (advantage && !disadvantage) {
                    result.dice = [roll1, roll2];
                    result.total = Math.max(roll1, roll2);
                    result.type = 'advantage';
                } else if (disadvantage && !advantage) {
                    result.dice = [roll1, roll2];
                    result.total = Math.min(roll1, roll2);
                    result.type = 'disadvantage';
                } else if (advantage && disadvantage) {
                    result.type = 'normal'; // Advantage and disadvantage cancel out
                }
                
                return result;
            }
            
            // ===== GROUP ABILITY CHECKS =====
            rollGroupCheck(characters, skill, dc, advantage = false, disadvantage = false) {
                const results = characters.map(character => {
                    return this.rollSkillCheck(character, skill, advantage, disadvantage);
                });
                
                const successes = results.filter(result => result.total >= dc).length;
                const required = Math.ceil(characters.length / 2);
                const groupSuccess = successes >= required;
                
                const groupResult = {
                    type: 'group_check',
                    skill: skill,
                    dc: dc,
                    characters: characters.map(c => c.name),
                    results: results,
                    successes: successes,
                    required: required,
                    success: groupSuccess,
                    timestamp: new Date().toISOString()
                };
                
                this.checkHistory.push(groupResult);
                return groupResult;
            }
            
            // ===== SKILL CONTESTS =====
            rollSkillContest(character1, character2, skill1, skill2 = null, advantage1 = false, advantage2 = false) {
                skill2 = skill2 || skill1; // Use same skill if not specified
                
                const result1 = this.rollSkillCheck(character1, skill1, advantage1);
                const result2 = this.rollSkillCheck(character2, skill2, advantage2);
                
                let winner = null;
                if (result1.total > result2.total) {
                    winner = character1.name;
                } else if (result2.total > result1.total) {
                    winner = character2.name;
                } else {
                    // Tie - higher ability modifier wins
                    const mod1 = this.getAbilityModifier(character1[this.skills[skill1]] || 10);
                    const mod2 = this.getAbilityModifier(character2[this.skills[skill2]] || 10);
                    
                    if (mod1 > mod2) {
                        winner = character1.name;
                    } else if (mod2 > mod1) {
                        winner = character2.name;
                    }
                    // If still tied, it's a draw
                }
                
                const contestResult = {
                    type: 'skill_contest',
                    contestant1: {
                        character: character1.name,
                        skill: skill1,
                        result: result1
                    },
                    contestant2: {
                        character: character2.name,
                        skill: skill2,
                        result: result2
                    },
                    winner: winner,
                    margin: Math.abs(result1.total - result2.total),
                    timestamp: new Date().toISOString()
                };
                
                this.checkHistory.push(contestResult);
                return contestResult;
            }
            
            // ===== HELPING MECHANICS =====
            rollWithHelp(character, helper, skill, dc, advantage = false, disadvantage = false) {
                // Helper makes a DC 10 check to assist
                const helpCheck = this.rollSkillCheck(helper, skill);
                const canHelp = helpCheck.total >= 10;
                
                // Main character gets advantage if helper succeeds
                const finalAdvantage = canHelp || advantage;
                
                const mainResult = this.rollSkillCheck(character, skill, finalAdvantage, disadvantage);
                
                const helpResult = {
                    type: 'help_action',
                    character: character.name,
                    helper: helper.name,
                    skill: skill,
                    dc: dc,
                    helpCheck: helpCheck,
                    helpSucceeded: canHelp,
                    mainResult: mainResult,
                    success: mainResult.total >= dc,
                    timestamp: new Date().toISOString()
                };
                
                this.checkHistory.push(helpResult);
                return helpResult;
            }
            
            // ===== VARIANT ABILITY CHECKS =====
            rollVariantCheck(character, skill, variantAbility, advantage = false, disadvantage = false, bonus = 0) {
                // Examples: Strength (Intimidation), Constitution (Performance), etc.
                return this.rollSkillCheck(character, skill, advantage, disadvantage, bonus, variantAbility);
            }
            
            // ===== ACTIVE CHECK MANAGEMENT =====
            startActiveCheck(name, description, participants, skill, dc, timeLimit = null) {
                const activeCheck = {
                    id: Date.now(),
                    name: name,
                    description: description,
                    participants: participants,
                    skill: skill,
                    dc: dc,
                    timeLimit: timeLimit,
                    results: [],
                    completed: false,
                    startTime: new Date().toISOString()
                };
                
                this.activeChecks.push(activeCheck);
                return activeCheck;
            }
            
            completeActiveCheck(checkId, results) {
                const check = this.activeChecks.find(c => c.id === checkId);
                if (check) {
                    check.results = results;
                    check.completed = true;
                    check.endTime = new Date().toISOString();
                    
                    // Move to history
                    this.checkHistory.push(check);
                }
                
                return check;
            }
            
            // ===== DIFFICULTY CLASS HELPERS =====
            getDCDescription(dc) {
                if (dc <= 5) return 'Very Easy';
                if (dc <= 10) return 'Easy';
                if (dc <= 15) return 'Medium';
                if (dc <= 20) return 'Hard';
                if (dc <= 25) return 'Very Hard';
                return 'Nearly Impossible';
            }
            
            suggestDC(taskDescription, characterLevel = 1) {
                // Basic DC suggestions based on task and character level
                const baseDCs = {
                    'trivial': 5,
                    'easy': 8 + Math.floor(characterLevel / 4),
                    'medium': 12 + Math.floor(characterLevel / 4),
                    'hard': 16 + Math.floor(characterLevel / 4),
                    'very_hard': 20 + Math.floor(characterLevel / 4),
                    'impossible': 25 + Math.floor(characterLevel / 4)
                };
                
                // Keyword matching for automatic suggestions
                const task = taskDescription.toLowerCase();
                
                if (task.includes('simple') || task.includes('basic') || task.includes('obvious')) {
                    return { dc: baseDCs.easy, description: 'Easy' };
                }
                if (task.includes('difficult') || task.includes('complex') || task.includes('challenging')) {
                    return { dc: baseDCs.hard, description: 'Hard' };
                }
                if (task.includes('impossible') || task.includes('legendary') || task.includes('epic')) {
                    return { dc: baseDCs.impossible, description: 'Nearly Impossible' };
                }
                
                return { dc: baseDCs.medium, description: 'Medium' };
            }
            
            // ===== CHECK HISTORY AND ANALYSIS =====
            getCheckHistory(characterName = null, skill = null, limit = 50) {
                let filtered = [...this.checkHistory];
                
                if (characterName) {
                    filtered = filtered.filter(check => {
                        if (check.character === characterName) return true;
                        if (check.characters?.includes(characterName)) return true;
                        if (check.contestant1?.character === characterName) return true;
                        if (check.contestant2?.character === characterName) return true;
                        return false;
                    });
                }
                
                if (skill) {
                    filtered = filtered.filter(check => check.skill === skill);
                }
                
                return filtered.slice(-limit).reverse();
            }
            
            getCharacterStatistics(character) {
                const checks = this.getCheckHistory(character.name);
                const stats = {
                    totalChecks: checks.length,
                    successRate: 0,
                    skillBreakdown: {},
                    averageRoll: 0,
                    nat20s: 0,
                    nat1s: 0
                };
                
                if (checks.length === 0) return stats;
                
                let successCount = 0;
                let rollSum = 0;
                let rollCount = 0;
                
                checks.forEach(check => {
                    // Count successes (for checks with DCs)
                    if (check.dc && check.total >= check.dc) successCount++;
                    if (check.success === true) successCount++;
                    
                    // Track skill usage
                    if (check.skill) {
                        stats.skillBreakdown[check.skill] = (stats.skillBreakdown[check.skill] || 0) + 1;
                    }
                    
                    // Track roll statistics
                    if (check.roll) {
                        check.roll.dice.forEach(die => {
                            rollSum += die;
                            rollCount++;
                            if (die === 20) stats.nat20s++;
                            if (die === 1) stats.nat1s++;
                        });
                    }
                });
                
                stats.successRate = (successCount / checks.length) * 100;
                stats.averageRoll = rollCount > 0 ? rollSum / rollCount : 0;
                
                return stats;
            }
            
            clearHistory() {
                this.checkHistory = [];
                this.activeChecks = [];
                this.passiveScores = {};
            }
        }
        
        // ===== ADVANCED SAVING THROW SYSTEM =====
        class SavingThrowSystem {
            constructor() {
                this.savingThrows = ['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'];
                this.saveHistory = [];
                this.massiveHistory = [];
                
                // Class saving throw proficiencies (D&D 5e)
                this.classSaveProficiencies = {
                    'barbarian': ['strength', 'constitution'],
                    'bard': ['dexterity', 'charisma'],
                    'cleric': ['wisdom', 'charisma'],
                    'druid': ['intelligence', 'wisdom'],
                    'fighter': ['strength', 'constitution'],
                    'monk': ['strength', 'dexterity'],
                    'paladin': ['wisdom', 'charisma'],
                    'ranger': ['strength', 'dexterity'],
                    'rogue': ['dexterity', 'intelligence'],
                    'sorcerer': ['constitution', 'charisma'],
                    'warlock': ['wisdom', 'charisma'],
                    'wizard': ['intelligence', 'wisdom']
                };
                
                // Common condition effects on saves (D&D 5e RAW)
                this.conditionEffects = {
                    'stunned': { saves: ['strength', 'dexterity'], effect: 'auto_fail' },
                    'unconscious': { saves: ['strength', 'dexterity'], effect: 'auto_fail' },
                    'paralyzed': { saves: ['strength', 'dexterity'], effect: 'auto_fail' },
                    'blessed': { saves: ['all'], effect: '+1d4' },
                    'magic_resistance': { saves: ['magic'], effect: 'advantage' }
                };
                
                // Damage type classifications for saves
                this.magicalSaves = [
                    'spell', 'magic', 'psychic', 'force', 'radiant', 'necrotic', 
                    'enchantment', 'evocation', 'illusion', 'divination', 'transmutation', 'conjuration'
                ];
            }
            
            // ===== CORE SAVING THROW MECHANICS =====
            rollSavingThrow(character, save, dc, advantage = false, disadvantage = false, bonus = 0, source = 'manual') {
                const abilityScore = character[save] || 10;
                const abilityMod = this.getAbilityModifier(abilityScore);
                let totalBonus = abilityMod + bonus;
                
                // Add proficiency bonus if proficient
                if (this.isProfficientInSave(character, save)) {
                    const profBonus = this.getProficiencyBonus(character.level || 1);
                    totalBonus += profBonus;
                }
                
                // Apply character-specific save bonuses
                if (character.saveBonuses && character.saveBonuses[save]) {
                    totalBonus += character.saveBonuses[save];
                }
                
                // Apply condition effects
                const conditionModifiers = this.getConditionModifiers(character, save, source);
                advantage = advantage || conditionModifiers.advantage;
                disadvantage = disadvantage || conditionModifiers.disadvantage;
                totalBonus += conditionModifiers.bonus;
                
                // Handle auto-fail conditions
                if (conditionModifiers.autoFail) {
                    const result = {
                        type: 'saving_throw',
                        character: character.name,
                        save: save,
                        dc: dc,
                        roll: { dice: [1], total: 1, type: 'auto_fail' },
                        modifier: totalBonus,
                        total: 1 + totalBonus,
                        success: false,
                        degree: 'failure',
                        advantage: advantage,
                        disadvantage: disadvantage,
                        source: source,
                        autoFail: true,
                        timestamp: new Date().toISOString()
                    };
                    
                    this.saveHistory.push(result);
                    return result;
                }
                
                // Roll the dice
                const roll = this.rollWithAdvantage(advantage, disadvantage);
                const total = roll.total + totalBonus;
                const success = total >= dc;
                
                // Determine degree of success/failure
                let degree = 'failure';
                if (success) {
                    degree = total >= dc + 10 ? 'critical_success' : 'success';
                } else {
                    degree = roll.total === 1 ? 'critical_failure' : 'failure';
                }
                
                const result = {
                    type: 'saving_throw',
                    character: character.name,
                    save: save,
                    dc: dc,
                    roll: roll,
                    modifier: totalBonus,
                    total: total,
                    success: success,
                    degree: degree,
                    advantage: advantage,
                    disadvantage: disadvantage,
                    source: source,
                    timestamp: new Date().toISOString()
                };
                
                this.saveHistory.push(result);
                return result;
            }
            
            // ===== DEATH SAVING THROWS =====
            rollDeathSave(character, advantage = false, disadvantage = false) {
                const roll = this.rollWithAdvantage(advantage, disadvantage);
                
                let result = {
                    type: 'death_save',
                    character: character.name,
                    roll: roll,
                    success: roll.total >= 10,
                    criticalSuccess: roll.total === 20,
                    criticalFailure: roll.total === 1,
                    advantage: advantage,
                    disadvantage: disadvantage,
                    timestamp: new Date().toISOString()
                };
                
                // Apply death save results to character
                if (!character.deathSaves) {
                    character.deathSaves = { successes: 0, failures: 0 };
                }
                
                if (result.criticalSuccess) {
                    // Natural 20 - regain 1 hp and become conscious
                    character.hp = 1;
                    character.conditions = character.conditions?.filter(c => c !== 'unconscious') || [];
                    character.deathSaves = { successes: 0, failures: 0 };
                    result.effect = 'regain_consciousness';
                } else if (result.criticalFailure) {
                    // Natural 1 - count as 2 failures
                    character.deathSaves.failures += 2;
                    result.effect = 'double_failure';
                } else if (result.success) {
                    character.deathSaves.successes += 1;
                    result.effect = 'success';
                } else {
                    character.deathSaves.failures += 1;
                    result.effect = 'failure';
                }
                
                // Check for stabilization or death
                if (character.deathSaves.successes >= 3) {
                    character.conditions = character.conditions?.filter(c => c !== 'dying') || [];
                    character.conditions.push('stable');
                    character.deathSaves = { successes: 0, failures: 0 };
                    result.stabilized = true;
                } else if (character.deathSaves.failures >= 3) {
                    character.conditions = character.conditions?.filter(c => !['dying', 'unconscious'].includes(c)) || [];
                    character.conditions.push('dead');
                    character.deathSaves = { successes: 0, failures: 0 };
                    result.died = true;
                }
                
                this.saveHistory.push(result);
                return result;
            }
            
            // ===== MASS SAVING THROWS =====
            rollMassSaves(characters, save, dc, advantage = false, disadvantage = false, source = 'spell') {
                const results = characters.map(character => {
                    return this.rollSavingThrow(character, save, dc, advantage, disadvantage, 0, source);
                });
                
                const massResult = {
                    type: 'mass_saves',
                    save: save,
                    dc: dc,
                    source: source,
                    characters: characters.map(c => c.name),
                    results: results,
                    successes: results.filter(r => r.success).length,
                    failures: results.filter(r => !r.success).length,
                    timestamp: new Date().toISOString()
                };
                
                this.massiveHistory.push(massResult);
                return massResult;
            }
            
            // ===== CONDITION AND MODIFIER SYSTEM =====
            getConditionModifiers(character, save, source) {
                let advantage = false;
                let disadvantage = false;
                let bonus = 0;
                let autoFail = false;
                
                if (!character.conditions) return { advantage, disadvantage, bonus, autoFail };
                
                character.conditions.forEach(condition => {
                    const effect = this.conditionEffects[condition];
                    if (!effect) return;
                    
                    // Check if condition affects this save
                    const affectsSave = effect.saves.includes('all') || effect.saves.includes(save);
                    
                    // Special case for magic resistance
                    if (condition === 'magic_resistance' && this.isMagicalSource(source)) {
                        advantage = true;
                        return;
                    }
                    
                    if (affectsSave) {
                        switch (effect.effect) {
                            case 'advantage':
                                advantage = true;
                                break;
                            case 'disadvantage':
                                disadvantage = true;
                                break;
                            case 'auto_fail':
                                autoFail = true;
                                break;
                            case '+1d4':
                                bonus += Math.floor(Math.random() * 4) + 1; // Roll 1d4
                                break;
                        }
                    }
                });
                
                return { advantage, disadvantage, bonus, autoFail };
            }
            
            isMagicalSource(source) {
                if (typeof source !== 'string') return false;
                return this.magicalSaves.some(magical => source.toLowerCase().includes(magical));
            }
            
            // ===== PROFICIENCY SYSTEM =====
            isProfficientInSave(character, save) {
                // Check explicit save proficiencies
                if (character.saveProficiencies && character.saveProficiencies.includes(save)) {
                    return true;
                }
                
                // Check class-based proficiencies
                if (character.class) {
                    const classSaves = this.classSaveProficiencies[character.class.toLowerCase()];
                    return classSaves && classSaves.includes(save);
                }
                
                return false;
            }
            
            // ===== UTILITY METHODS =====
            getAbilityModifier(score) {
                return Math.floor((score - 10) / 2);
            }
            
            getProficiencyBonus(level) {
                return Math.ceil(level / 4) + 1;
            }
            
            rollWithAdvantage(advantage = false, disadvantage = false) {
                const roll1 = Math.floor(Math.random() * 20) + 1;
                const roll2 = Math.floor(Math.random() * 20) + 1;
                
                let result = {
                    dice: [roll1],
                    total: roll1
                };
                
                if (advantage && !disadvantage) {
                    result.dice = [roll1, roll2];
                    result.total = Math.max(roll1, roll2);
                    result.type = 'advantage';
                } else if (disadvantage && !advantage) {
                    result.dice = [roll1, roll2];
                    result.total = Math.min(roll1, roll2);
                    result.type = 'disadvantage';
                } else if (advantage && disadvantage) {
                    result.type = 'normal'; // Cancel out
                }
                
                return result;
            }
            
            // ===== SAVE DC CALCULATIONS =====
            calculateSpellSaveDC(character) {
                const spellcastingAbility = this.getSpellcastingAbility(character.class);
                if (!spellcastingAbility) return null;
                
                const abilityMod = this.getAbilityModifier(character[spellcastingAbility] || 10);
                const profBonus = this.getProficiencyBonus(character.level || 1);
                
                return 8 + profBonus + abilityMod;
            }
            
            getSpellcastingAbility(characterClass) {
                const spellcastingAbilities = {
                    'bard': 'charisma',
                    'cleric': 'wisdom',
                    'druid': 'wisdom',
                    'paladin': 'charisma',
                    'ranger': 'wisdom',
                    'sorcerer': 'charisma',
                    'warlock': 'charisma',
                    'wizard': 'intelligence'
                };
                
                return spellcastingAbilities[characterClass?.toLowerCase()];
            }
            
            // ===== LEGENDARY RESISTANCE =====
            useLegendaryResistance(character, saveResult) {
                if (!character.legendaryResistances || character.legendaryResistances <= 0) {
                    return saveResult;
                }
                
                // Convert failure to success
                if (!saveResult.success) {
                    character.legendaryResistances -= 1;
                    saveResult.legendaryResistanceUsed = true;
                    saveResult.success = true;
                    saveResult.degree = 'legendary_success';
                    saveResult.total = saveResult.dc; // Set to exactly DC
                }
                
                return saveResult;
            }
            
            // ===== SAVE ANALYSIS AND STATISTICS =====
            getSaveStatistics(character) {
                const saves = this.saveHistory.filter(save => save.character === character.name);
                
                const stats = {
                    totalSaves: saves.length,
                    successRate: 0,
                    saveBreakdown: {},
                    deathSaves: {
                        total: 0,
                        successes: 0,
                        failures: 0,
                        criticalSuccesses: 0,
                        criticalFailures: 0
                    },
                    averageRoll: 0,
                    nat20s: 0,
                    nat1s: 0
                };
                
                if (saves.length === 0) return stats;
                
                let successCount = 0;
                let rollSum = 0;
                let rollCount = 0;
                
                saves.forEach(save => {
                    if (save.success) successCount++;
                    
                    // Track save type usage
                    if (save.save) {
                        stats.saveBreakdown[save.save] = (stats.saveBreakdown[save.save] || 0) + 1;
                    }
                    
                    // Death save statistics
                    if (save.type === 'death_save') {
                        stats.deathSaves.total++;
                        if (save.success) stats.deathSaves.successes++;
                        else stats.deathSaves.failures++;
                        if (save.criticalSuccess) stats.deathSaves.criticalSuccesses++;
                        if (save.criticalFailure) stats.deathSaves.criticalFailures++;
                    }
                    
                    // Roll statistics
                    if (save.roll && save.roll.dice) {
                        save.roll.dice.forEach(die => {
                            rollSum += die;
                            rollCount++;
                            if (die === 20) stats.nat20s++;
                            if (die === 1) stats.nat1s++;
                        });
                    }
                });
                
                stats.successRate = (successCount / saves.length) * 100;
                stats.averageRoll = rollCount > 0 ? rollSum / rollCount : 0;
                
                return stats;
            }
            
            // ===== SAVE RECOMMENDATIONS =====
            getSaveRecommendations(character, save, dc) {
                const abilityScore = character[save] || 10;
                const modifier = this.getAbilityModifier(abilityScore);
                const proficient = this.isProfficientInSave(character, save);
                const profBonus = proficient ? this.getProficiencyBonus(character.level || 1) : 0;
                const totalBonus = modifier + profBonus;
                
                const neededRoll = dc - totalBonus;
                const successChance = Math.max(0, Math.min(100, (21 - neededRoll) * 5));
                
                const recommendations = [];
                
                if (successChance < 25) {
                    recommendations.push('Very difficult save - consider using inspiration or abilities that grant advantage');
                }
                
                if (!proficient && character.level >= 4) {
                    recommendations.push(`Consider taking Resilient (${save.charAt(0).toUpperCase() + save.slice(1)}) feat for proficiency`);
                }
                
                if (character.conditions?.includes('poisoned') && save === 'constitution') {
                    recommendations.push('Poisoned condition gives disadvantage on Constitution saves');
                }
                
                return {
                    successChance: successChance,
                    neededRoll: neededRoll,
                    recommendations: recommendations
                };
            }
            
            // ===== HISTORY MANAGEMENT =====
            getSaveHistory(characterName = null, saveType = null, limit = 50) {
                let filtered = [...this.saveHistory];
                
                if (characterName) {
                    filtered = filtered.filter(save => save.character === characterName);
                }
                
                if (saveType) {
                    filtered = filtered.filter(save => save.save === saveType || save.type === saveType);
                }
                
                return filtered.slice(-limit).reverse();
            }
            
            clearHistory() {
                this.saveHistory = [];
                this.massiveHistory = [];
            }
        }
        
        // ===== COMPREHENSIVE RULES REFERENCE SYSTEM =====
        class RulesReferenceSystem {
            constructor() {
                this.searchHistory = [];
                this.bookmarkedRules = JSON.parse(localStorage.getItem('dnd_bookmarked_rules') || '[]');
                
                // Complete D&D 5e rules database
                this.rulesDatabase = {
                    combat: {
                        'initiative': {
                            name: 'Initiative',
                            category: 'Combat',
                            description: 'At the beginning of combat, every participant makes a Dexterity check to determine initiative order.',
                            rules: 'Roll 1d20 + Dexterity modifier. Act in descending order. Ties go to highest Dexterity score.',
                            page: 'PHB 189',
                            tags: ['combat', 'dexterity', 'turn order']
                        },
                        'attack_roll': {
                            name: 'Attack Roll',
                            category: 'Combat',
                            description: 'Roll to determine if an attack hits its target.',
                            rules: '1d20 + ability modifier + proficiency bonus (if proficient) vs target AC. Natural 20 is critical hit.',
                            page: 'PHB 194',
                            tags: ['combat', 'attack', 'roll', 'critical']
                        },
                        'critical_hit': {
                            name: 'Critical Hit',
                            category: 'Combat',
                            description: 'When you roll a natural 20 on an attack roll.',
                            rules: 'Double all damage dice rolled. Add modifiers normally.',
                            page: 'PHB 196',
                            tags: ['combat', 'damage', 'critical', 'natural 20']
                        },
                        'opportunity_attack': {
                            name: 'Opportunity Attack',
                            category: 'Combat',
                            description: 'Attack triggered when a creature moves out of your reach.',
                            rules: 'Use your reaction to make one melee attack against the provoking creature.',
                            page: 'PHB 195',
                            tags: ['combat', 'reaction', 'movement', 'melee']
                        },
                        'grappling': {
                            name: 'Grappling',
                            category: 'Combat',
                            description: 'Use Attack action with free hand to grab creature within one size category.',
                            rules: 'Athletics check vs target\'s Athletics or Acrobatics. Success: target speed becomes 0, can move at half speed dragging target. Target can use action to escape with same contest.',
                            page: 'PHB 195',
                            tags: ['combat', 'athletics', 'attack action', 'contest', 'speed']
                        },
                        'shoving': {
                            name: 'Shoving',
                            category: 'Combat',
                            description: 'Push a creature away or knock it prone.',
                            rules: 'Athletics check vs target\'s Athletics or Acrobatics. Success pushes 5 feet or knocks prone.',
                            page: 'PHB 195',
                            tags: ['combat', 'athletics', 'prone', 'push']
                        },
                        'two_weapon_fighting': {
                            name: 'Two-Weapon Fighting',
                            category: 'Combat',
                            description: 'Fight with a light weapon in each hand.',
                            rules: 'Bonus action attack with off-hand light weapon. No ability modifier to damage unless negative.',
                            page: 'PHB 195',
                            tags: ['combat', 'bonus action', 'light weapons', 'dual wield']
                        },
                        'cover': {
                            name: 'Cover',
                            category: 'Combat',
                            description: 'Obstacles provide protection from attacks.',
                            rules: 'Half cover: +2 AC/Dex saves. Three-quarters: +5 AC/Dex saves. Total: Can\'t be targeted.',
                            page: 'PHB 196',
                            tags: ['combat', 'ac', 'dexterity saves', 'protection']
                        }
                    },
                    spellcasting: {
                        'spell_attack_roll': {
                            name: 'Spell Attack Roll',
                            category: 'Spellcasting',
                            description: 'Roll to hit with a spell that requires an attack.',
                            rules: '1d20 + spellcasting ability modifier + proficiency bonus vs target AC.',
                            page: 'PHB 205',
                            tags: ['spells', 'attack', 'spellcasting modifier']
                        },
                        'spell_save_dc': {
                            name: 'Spell Save DC',
                            category: 'Spellcasting',
                            description: 'Difficulty Class for saving throws against spells.',
                            rules: '8 + spellcasting ability modifier + proficiency bonus.',
                            page: 'PHB 205',
                            tags: ['spells', 'saving throws', 'dc']
                        },
                        'concentration': {
                            name: 'Concentration',
                            category: 'Spellcasting',
                            description: 'Maintaining focus on ongoing spell effects.',
                            rules: 'Constitution save when taking damage: DC 10 or half damage taken (whichever is higher).',
                            page: 'PHB 203',
                            tags: ['spells', 'constitution', 'damage', 'focus']
                        },
                        'ritual_casting': {
                            name: 'Ritual Casting',
                            category: 'Spellcasting',
                            description: 'Cast certain spells without using spell slots.',
                            rules: 'Takes 10 minutes longer. Must know spell. No spell slot consumed.',
                            page: 'PHB 201',
                            tags: ['spells', 'ritual', 'spell slots', 'time']
                        },
                        'counterspell': {
                            name: 'Counterspell',
                            category: 'Spellcasting',
                            description: 'Interrupt another creature\'s spellcasting.',
                            rules: 'Reaction. Auto-success if spell is 3rd level or lower. Higher: spellcasting check DC 10 + spell level.',
                            page: 'PHB 228',
                            tags: ['spells', 'reaction', 'interrupt', 'spellcasting check']
                        }
                    },
                    abilities: {
                        'ability_check': {
                            name: 'Ability Check',
                            category: 'Abilities',
                            description: 'Roll to determine success of an action.',
                            rules: '1d20 + ability modifier + proficiency bonus (if applicable).',
                            page: 'PHB 174',
                            tags: ['ability', 'check', 'proficiency', 'modifier']
                        },
                        'saving_throw': {
                            name: 'Saving Throw',
                            category: 'Abilities',
                            description: 'Roll to avoid or reduce harmful effects.',
                            rules: '1d20 + ability modifier + proficiency bonus (if proficient in that save).',
                            page: 'PHB 179',
                            tags: ['saving throw', 'ability', 'proficiency']
                        },
                        'passive_perception': {
                            name: 'Passive Perception',
                            category: 'Abilities',
                            description: 'Baseline awareness without actively looking.',
                            rules: '10 + Wisdom (Perception) modifier. Advantage adds +5, disadvantage subtracts 5.',
                            page: 'PHB 175',
                            tags: ['perception', 'wisdom', 'passive', 'awareness']
                        },
                        'advantage_disadvantage': {
                            name: 'Advantage/Disadvantage',
                            category: 'Abilities',
                            description: 'Roll two d20s and take higher/lower result.',
                            rules: 'Advantage: take higher roll. Disadvantage: take lower roll. Multiple sources don\'t stack.',
                            page: 'PHB 173',
                            tags: ['advantage', 'disadvantage', 'roll', 'd20']
                        }
                    },
                    conditions: {
                        'blinded': {
                            name: 'Blinded',
                            category: 'Conditions',
                            description: 'Cannot see and automatically fails sight-based checks.',
                            rules: 'Attack rolls have disadvantage. Attacks against you have advantage.',
                            page: 'PHB 290',
                            tags: ['condition', 'sight', 'disadvantage', 'advantage']
                        },
                        'charmed': {
                            name: 'Charmed',
                            category: 'Conditions',
                            description: 'Cannot attack the charmer or target them with harmful abilities.',
                            rules: 'Charmer has advantage on social interaction checks with you.',
                            page: 'PHB 290',
                            tags: ['condition', 'charmer', 'social', 'interaction']
                        },
                        'frightened': {
                            name: 'Frightened',
                            category: 'Conditions',
                            description: 'Disadvantage on ability checks and attacks while source is in sight.',
                            rules: 'Cannot willingly move closer to the source of fear.',
                            page: 'PHB 290',
                            tags: ['condition', 'fear', 'disadvantage', 'movement']
                        },
                        'poisoned': {
                            name: 'Poisoned',
                            category: 'Conditions',
                            description: 'Disadvantage on attack rolls and ability checks.',
                            rules: 'Does not affect saving throws.',
                            page: 'PHB 292',
                            tags: ['condition', 'poison', 'disadvantage', 'attacks', 'checks']
                        },
                        'prone': {
                            name: 'Prone',
                            category: 'Conditions',
                            description: 'Lying flat on the ground.',
                            rules: 'Disadvantage on attacks. Attacks within 5 feet have advantage, beyond 5 feet have disadvantage.',
                            page: 'PHB 292',
                            tags: ['condition', 'ground', 'attacks', 'range']
                        },
                        'restrained': {
                            name: 'Restrained',
                            category: 'Conditions',
                            description: 'Speed becomes 0 and cannot benefit from bonuses to speed.',
                            rules: 'Disadvantage on attacks and Dex saves. Attacks against you have advantage.',
                            page: 'PHB 292',
                            tags: ['condition', 'speed', 'movement', 'dexterity']
                        }
                    },
                    environment: {
                        'difficult_terrain': {
                            name: 'Difficult Terrain',
                            category: 'Environment',
                            description: 'Terrain that impedes movement.',
                            rules: 'Every foot of movement costs 1 extra foot (2 feet total per foot moved).',
                            page: 'PHB 182',
                            tags: ['terrain', 'movement', 'speed', 'cost']
                        },
                        'falling': {
                            name: 'Falling',
                            category: 'Environment',
                            description: 'Taking damage from falling great distances.',
                            rules: '1d6 bludgeoning damage per 10 feet fallen, maximum 20d6.',
                            page: 'PHB 183',
                            tags: ['damage', 'bludgeoning', 'distance', 'height']
                        },
                        'suffocation': {
                            name: 'Suffocation',
                            category: 'Environment',
                            description: 'Running out of breathable air.',
                            rules: 'Hold breath for 1 + Con modifier minutes (minimum 30 seconds). Then drop to 0 hp.',
                            page: 'PHB 183',
                            tags: ['breath', 'constitution', 'unconscious', 'death']
                        },
                        'vision_light': {
                            name: 'Vision and Light',
                            category: 'Environment',
                            description: 'How lighting affects what creatures can see.',
                            rules: 'Bright: normal vision. Dim: lightly obscured. Darkness: heavily obscured.',
                            page: 'PHB 183',
                            tags: ['vision', 'light', 'obscured', 'darkness']
                        }
                    },
                    rests: {
                        'short_rest': {
                            name: 'Short Rest',
                            category: 'Rests',
                            description: 'A period of downtime lasting at least 1 hour.',
                            rules: 'Spend Hit Dice to recover hp. Regain some class features.',
                            page: 'PHB 186',
                            tags: ['rest', 'hit dice', 'healing', 'recovery']
                        },
                        'long_rest': {
                            name: 'Long Rest',
                            category: 'Rests',
                            description: 'Extended period of downtime lasting at least 8 hours.',
                            rules: 'Regain all hp and half your total Hit Dice. Regain spell slots and class features.',
                            page: 'PHB 186',
                            tags: ['rest', 'healing', 'spell slots', 'recovery']
                        }
                    }
                };
                
                // Combat actions quick reference
                this.combatActions = {
                    action: [
                        'Attack', 'Cast a Spell', 'Dash', 'Disengage', 'Dodge', 'Help', 'Hide', 'Ready', 'Search', 'Use an Object'
                    ],
                    bonus_action: [
                        'Off-hand Attack (two-weapon fighting)', 'Spell (if specified)', 'Class Feature (various)'
                    ],
                    reaction: [
                        'Opportunity Attack', 'Cast a Spell (if specified)', 'Ready Action Trigger'
                    ],
                    movement: [
                        'Move up to your speed', 'Stand up from prone (half movement)', 'Climb/Swim (difficult terrain rules)'
                    ],
                    free: [
                        'Draw/Sheathe weapon', 'Open door', 'Say something', 'Gesture'
                    ]
                };
            }
            
            // ===== SEARCH FUNCTIONALITY =====
            searchRules(query, category = null, tags = null) {
                const searchTerms = query.toLowerCase().split(' ');
                const results = [];
                
                // Search through all rule categories
                Object.entries(this.rulesDatabase).forEach(([categoryName, rules]) => {
                    if (category && categoryName !== category) return;
                    
                    Object.entries(rules).forEach(([ruleId, rule]) => {
                        let score = 0;
                        
                        // Check rule name
                        const ruleName = rule.name.toLowerCase();
                        searchTerms.forEach(term => {
                            if (ruleName.includes(term)) score += 10;
                        });
                        
                        // Check description
                        const description = rule.description.toLowerCase();
                        searchTerms.forEach(term => {
                            if (description.includes(term)) score += 5;
                        });
                        
                        // Check rules text
                        const rulesText = rule.rules.toLowerCase();
                        searchTerms.forEach(term => {
                            if (rulesText.includes(term)) score += 3;
                        });
                        
                        // Check tags
                        if (rule.tags) {
                            rule.tags.forEach(tag => {
                                searchTerms.forEach(term => {
                                    if (tag.includes(term)) score += 7;
                                });
                            });
                        }
                        
                        // Filter by tags if specified
                        if (tags && tags.length > 0) {
                            const hasAllTags = tags.every(requiredTag => 
                                rule.tags && rule.tags.includes(requiredTag)
                            );
                            if (!hasAllTags) score = 0;
                        }
                        
                        if (score > 0) {
                            results.push({
                                ...rule,
                                id: ruleId,
                                categoryName: categoryName,
                                score: score
                            });
                        }
                    });
                });
                
                // Sort by relevance score
                results.sort((a, b) => b.score - a.score);
                
                // Record search
                this.searchHistory.push({
                    query: query,
                    category: category,
                    tags: tags,
                    results: results.length,
                    timestamp: new Date().toISOString()
                });
                
                return results.slice(0, 20); // Limit to top 20 results
            }
            
            // ===== QUICK LOOKUPS =====
            getRule(ruleId, category = null) {
                if (category) {
                    return this.rulesDatabase[category]?.[ruleId] || null;
                }
                
                // Search all categories
                for (const [categoryName, rules] of Object.entries(this.rulesDatabase)) {
                    if (rules[ruleId]) {
                        return { ...rules[ruleId], categoryName: categoryName };
                    }
                }
                
                return null;
            }
            
            getCondition(conditionName) {
                return this.getRule(conditionName.toLowerCase(), 'conditions');
            }
            
            getCombatRule(ruleName) {
                return this.getRule(ruleName.toLowerCase().replace(/\s+/g, '_'), 'combat');
            }
            
            getSpellcastingRule(ruleName) {
                return this.getRule(ruleName.toLowerCase().replace(/\s+/g, '_'), 'spellcasting');
            }
            
            // ===== COMBAT ACTIONS REFERENCE =====
            getCombatActions(actionType = null) {
                if (actionType) {
                    return this.combatActions[actionType] || [];
                }
                return this.combatActions;
            }
            
            // ===== BOOKMARKING SYSTEM =====
            bookmarkRule(ruleId, category) {
                const bookmark = {
                    ruleId: ruleId,
                    category: category,
                    timestamp: new Date().toISOString()
                };
                
                // Check if already bookmarked
                const exists = this.bookmarkedRules.find(b => 
                    b.ruleId === ruleId && b.category === category
                );
                
                if (!exists) {
                    this.bookmarkedRules.push(bookmark);
                    this.saveBookmarks();
                }
                
                return bookmark;
            }
            
            removeBookmark(ruleId, category) {
                this.bookmarkedRules = this.bookmarkedRules.filter(b => 
                    !(b.ruleId === ruleId && b.category === category)
                );
                this.saveBookmarks();
            }
            
            getBookmarkedRules() {
                return this.bookmarkedRules.map(bookmark => {
                    const rule = this.getRule(bookmark.ruleId, bookmark.category);
                    return rule ? { ...rule, ...bookmark } : null;
                }).filter(Boolean);
            }
            
            saveBookmarks() {
                localStorage.setItem('dnd_bookmarked_rules', JSON.stringify(this.bookmarkedRules));
            }
            
            // ===== CATEGORY BROWSING =====
            getCategory(categoryName) {
                return this.rulesDatabase[categoryName] || null;
            }
            
            getAllCategories() {
                return Object.keys(this.rulesDatabase);
            }
            
            getRulesByCategory(categoryName) {
                const category = this.rulesDatabase[categoryName];
                if (!category) return [];
                
                return Object.entries(category).map(([id, rule]) => ({
                    ...rule,
                    id: id,
                    categoryName: categoryName
                }));
            }
            
            // ===== TAG SYSTEM =====
            getAllTags() {
                const tags = new Set();
                
                Object.values(this.rulesDatabase).forEach(category => {
                    Object.values(category).forEach(rule => {
                        if (rule.tags) {
                            rule.tags.forEach(tag => tags.add(tag));
                        }
                    });
                });
                
                return Array.from(tags).sort();
            }
            
            getRulesByTag(tag) {
                const results = [];
                
                Object.entries(this.rulesDatabase).forEach(([categoryName, rules]) => {
                    Object.entries(rules).forEach(([ruleId, rule]) => {
                        if (rule.tags && rule.tags.includes(tag)) {
                            results.push({
                                ...rule,
                                id: ruleId,
                                categoryName: categoryName
                            });
                        }
                    });
                });
                
                return results;
            }
            
            // ===== ADVANCED SEARCH =====
            advancedSearch(options = {}) {
                const {
                    query = '',
                    categories = [],
                    tags = [],
                    includeDescription = true,
                    includeRules = true,
                    exactMatch = false,
                    limit = 50
                } = options;
                
                const results = [];
                const searchTerms = exactMatch ? [query.toLowerCase()] : query.toLowerCase().split(' ');
                
                Object.entries(this.rulesDatabase).forEach(([categoryName, rules]) => {
                    if (categories.length > 0 && !categories.includes(categoryName)) return;
                    
                    Object.entries(rules).forEach(([ruleId, rule]) => {
                        let score = 0;
                        let matches = [];
                        
                        // Tag filtering first (hard requirement)
                        if (tags.length > 0) {
                            const hasAllTags = tags.every(requiredTag => 
                                rule.tags && rule.tags.includes(requiredTag)
                            );
                            if (!hasAllTags) return;
                        }
                        
                        if (query) {
                            // Search rule name
                            const ruleName = rule.name.toLowerCase();
                            searchTerms.forEach(term => {
                                if (exactMatch ? ruleName === term : ruleName.includes(term)) {
                                    score += 15;
                                    matches.push(`name: ${term}`);
                                }
                            });
                            
                            // Search description
                            if (includeDescription) {
                                const description = rule.description.toLowerCase();
                                searchTerms.forEach(term => {
                                    if (exactMatch ? description === term : description.includes(term)) {
                                        score += 8;
                                        matches.push(`description: ${term}`);
                                    }
                                });
                            }
                            
                            // Search rules text
                            if (includeRules) {
                                const rulesText = rule.rules.toLowerCase();
                                searchTerms.forEach(term => {
                                    if (exactMatch ? rulesText === term : rulesText.includes(term)) {
                                        score += 5;
                                        matches.push(`rules: ${term}`);
                                    }
                                });
                            }
                            
                            // Search tags
                            if (rule.tags) {
                                rule.tags.forEach(tag => {
                                    searchTerms.forEach(term => {
                                        if (exactMatch ? tag === term : tag.includes(term)) {
                                            score += 10;
                                            matches.push(`tag: ${tag}`);
                                        }
                                    });
                                });
                            }
                        } else {
                            // No query, just return all matching tag/category filters
                            score = 1;
                        }
                        
                        if (score > 0) {
                            results.push({
                                ...rule,
                                id: ruleId,
                                categoryName: categoryName,
                                score: score,
                                matches: matches
                            });
                        }
                    });
                });
                
                // Sort by relevance
                results.sort((a, b) => b.score - a.score);
                
                return results.slice(0, limit);
            }
            
            // ===== SEARCH HISTORY =====
            getSearchHistory(limit = 20) {
                return this.searchHistory.slice(-limit).reverse();
            }
            
            clearSearchHistory() {
                this.searchHistory = [];
            }
            
            // ===== RANDOM RULE =====
            getRandomRule(category = null) {
                let availableRules = [];
                
                if (category) {
                    const categoryRules = this.rulesDatabase[category];
                    if (categoryRules) {
                        availableRules = Object.entries(categoryRules).map(([id, rule]) => ({
                            ...rule,
                            id: id,
                            categoryName: category
                        }));
                    }
                } else {
                    Object.entries(this.rulesDatabase).forEach(([categoryName, rules]) => {
                        Object.entries(rules).forEach(([ruleId, rule]) => {
                            availableRules.push({
                                ...rule,
                                id: ruleId,
                                categoryName: categoryName
                            });
                        });
                    });
                }
                
                if (availableRules.length === 0) return null;
                
                const randomIndex = Math.floor(Math.random() * availableRules.length);
                return availableRules[randomIndex];
            }
            
            // ===== RULE STATISTICS =====
            getRuleStats() {
                const stats = {
                    totalRules: 0,
                    categoryCounts: {},
                    tagCounts: {},
                    mostSearched: [],
                    recentlyAdded: []
                };
                
                Object.entries(this.rulesDatabase).forEach(([categoryName, rules]) => {
                    const categoryCount = Object.keys(rules).length;
                    stats.categoryCounts[categoryName] = categoryCount;
                    stats.totalRules += categoryCount;
                    
                    Object.values(rules).forEach(rule => {
                        if (rule.tags) {
                            rule.tags.forEach(tag => {
                                stats.tagCounts[tag] = (stats.tagCounts[tag] || 0) + 1;
                            });
                        }
                    });
                });
                
                return stats;
            }
        }
        
        // ===== INTERACTIVE BATTLE MAP SYSTEM =====
        class BattleMapRenderer {
            constructor() {
                this.canvas = document.getElementById('map-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 20; // Grid width in cells
                this.height = 20; // Grid height in cells
                this.cellSize = 30; // Pixels per cell (6 feet per cell)
                this.gridColor = '#333';
                this.backgroundColor = '#1a1a1a';
                
                // Terrain and features
                this.terrain = new Map(); // Grid position -> terrain type
                this.features = new Map(); // Grid position -> map features
                
                // Token management
                this.tokens = new Map(); // Participant ID -> token data
                this.selectedToken = null;
                this.dragOffset = {x: 0, y: 0};
                this.isDragging = false;
                
                // Measurement and templates
                this.measurementLine = null;
                this.activeTemplates = []; // Area-of-effect templates
                this.measurementMode = false;
                
                // Visual effects
                this.highlights = new Map(); // Grid position -> highlight color
                this.animations = []; // Active animations
                
                this.initializeCanvas();
                this.setupEventListeners();
                this.startRenderLoop();
            }
            
            initializeCanvas() {
                // Set canvas size based on grid
                this.canvas.width = this.width * this.cellSize;
                this.canvas.height = this.height * this.cellSize;
                
                // Set display size
                this.canvas.style.width = `${this.canvas.width}px`;
                this.canvas.style.height = `${this.canvas.height}px`;
                
                // Enable smooth rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
            }
            
            setupEventListeners() {
                // Mouse events for interaction
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                
                // Keyboard events for shortcuts
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }
            
            getMousePosition(event) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            }
            
            pixelToGrid(x, y) {
                return {
                    x: Math.floor(x / this.cellSize),
                    y: Math.floor(y / this.cellSize)
                };
            }
            
            gridToPixel(gridX, gridY) {
                return {
                    x: gridX * this.cellSize + this.cellSize / 2,
                    y: gridY * this.cellSize + this.cellSize / 2
                };
            }
            
            // ===== RENDERING SYSTEM =====
            render() {
                // Clear canvas
                this.ctx.fillStyle = this.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.drawGrid();
                
                // Draw terrain and features
                this.drawTerrain();
                this.drawFeatures();
                
                // Draw highlights and effects
                this.drawHighlights();
                this.drawTemplates();
                
                // Draw tokens
                this.drawTokens();
                
                // Draw UI overlays
                this.drawMeasurement();
                this.drawSelectionHighlight();
                
                // Process animations
                this.updateAnimations();
            }
            
            drawGrid() {
                this.ctx.strokeStyle = this.gridColor;
                this.ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = 0; x <= this.width; x++) {
                    const pixelX = x * this.cellSize;
                    this.ctx.beginPath();
                    this.ctx.moveTo(pixelX, 0);
                    this.ctx.lineTo(pixelX, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= this.height; y++) {
                    const pixelY = y * this.cellSize;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, pixelY);
                    this.ctx.lineTo(this.canvas.width, pixelY);
                    this.ctx.stroke();
                }
                
                // Draw coordinate labels
                this.ctx.fillStyle = '#666';
                this.ctx.font = '8px monospace';
                for (let x = 0; x < this.width; x += 5) {
                    for (let y = 0; y < this.height; y += 5) {
                        const pixel = this.gridToPixel(x, y);
                        this.ctx.fillText(`${x},${y}`, pixel.x, pixel.y);
                    }
                }
            }
            
            drawTerrain() {
                this.terrain.forEach((terrainType, position) => {
                    const [x, y] = position.split(',').map(Number);
                    const pixel = this.gridToPixel(x, y);
                    
                    this.ctx.fillStyle = this.getTerrainColor(terrainType);
                    this.ctx.fillRect(
                        x * this.cellSize, 
                        y * this.cellSize, 
                        this.cellSize, 
                        this.cellSize
                    );
                });
            }
            
            getTerrainColor(terrainType) {
                const colors = {
                    'difficult': 'rgba(139, 69, 19, 0.3)', // Brown for difficult terrain
                    'water': 'rgba(0, 119, 190, 0.4)', // Blue for water
                    'lava': 'rgba(255, 69, 0, 0.6)', // Orange-red for lava
                    'ice': 'rgba(173, 216, 230, 0.4)', // Light blue for ice
                    'cover': 'rgba(128, 128, 128, 0.3)', // Gray for cover
                    'concealment': 'rgba(0, 0, 0, 0.2)' // Dark for concealment
                };
                return colors[terrainType] || 'rgba(255, 255, 255, 0.1)';
            }
            
            drawFeatures() {
                this.features.forEach((feature, position) => {
                    const [x, y] = position.split(',').map(Number);
                    const pixel = this.gridToPixel(x, y);
                    
                    // Draw feature based on type
                    this.ctx.fillStyle = feature.color || '#888';
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    
                    if (feature.type === 'wall') {
                        this.ctx.fillRect(x * this.cellSize + 2, y * this.cellSize + 2, 
                                         this.cellSize - 4, this.cellSize - 4);
                    } else if (feature.type === 'door') {
                        this.ctx.strokeRect(x * this.cellSize + 4, y * this.cellSize + 4,
                                          this.cellSize - 8, this.cellSize - 8);
                    }
                });
            }
            
            drawTokens() {
                this.tokens.forEach((token, participantId) => {
                    const pixel = this.gridToPixel(token.x, token.y);
                    
                    // Draw token base
                    this.ctx.fillStyle = token.color || this.getTokenColor(token.participant);
                    this.ctx.strokeStyle = token.selected ? '#FFD700' : '#000';
                    this.ctx.lineWidth = token.selected ? 3 : 1;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(pixel.x, pixel.y, (this.cellSize / 2) - 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Draw token label
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '10px bold sans-serif';
                    this.ctx.strokeStyle = '#000';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeText(token.label, pixel.x, pixel.y);
                    this.ctx.fillText(token.label, pixel.x, pixel.y);
                    
                    // Draw HP bar if damaged
                    if (token.participant.hp < token.participant.maxHp) {
                        this.drawHPBar(pixel.x, pixel.y, token.participant);
                    }
                    
                    // Draw status indicators
                    this.drawStatusIndicators(pixel.x, pixel.y, token.participant);
                });
            }
            
            getTokenColor(participant) {
                if (participant.hp <= 0) return '#800000'; // Dark red for unconscious/dead
                if (participant.isPlayer) return '#4169E1'; // Royal blue for players
                return '#DC143C'; // Crimson for enemies
            }
            
            drawHPBar(x, y, participant) {
                const barWidth = this.cellSize - 6;
                const barHeight = 4;
                const barX = x - barWidth / 2;
                const barY = y + this.cellSize / 2 - 8;
                
                const hpPercentage = Math.max(0, participant.hp) / participant.maxHp;
                
                // Background
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // HP bar
                const hpColor = hpPercentage > 0.5 ? '#4CAF50' : hpPercentage > 0.25 ? '#FFC107' : '#F44336';
                this.ctx.fillStyle = hpColor;
                this.ctx.fillRect(barX, barY, barWidth * hpPercentage, barHeight);
                
                // Border
                this.ctx.strokeStyle = '#000';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
            
            drawStatusIndicators(x, y, participant) {
                let iconX = x - this.cellSize / 2 + 5;
                const iconY = y - this.cellSize / 2 + 5;
                const iconSize = 8;
                
                // Conditions
                participant.conditions.forEach(condition => {
                    this.ctx.fillStyle = this.getConditionColor(condition.name);
                    this.ctx.fillRect(iconX, iconY, iconSize, iconSize);
                    iconX += iconSize + 2;
                });
                
                // Concentration
                if (participant.concentratingOn) {
                    this.ctx.fillStyle = '#9C27B0'; // Purple for concentration
                    this.ctx.beginPath();
                    this.ctx.arc(iconX + iconSize/2, iconY + iconSize/2, iconSize/2, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
            }
            
            getConditionColor(conditionName) {
                const colors = {
                    'Poisoned': '#4CAF50',
                    'Paralyzed': '#9E9E9E',
                    'Stunned': '#FFEB3B',
                    'Unconscious': '#607D8B',
                    'Charmed': '#E91E63',
                    'Frightened': '#FF5722',
                    'Restrained': '#795548',
                    'Grappled': '#FF9800'
                };
                return colors[conditionName] || '#666';
            }
            
            // ===== INTERACTION SYSTEM =====
            handleMouseDown(event) {
                const mouse = this.getMousePosition(event);
                const grid = this.pixelToGrid(mouse.x, mouse.y);
                
                // Check if clicking on a token
                const clickedToken = this.getTokenAtPosition(grid.x, grid.y);
                
                if (clickedToken) {
                    this.selectedToken = clickedToken;
                    this.isDragging = true;
                    
                    const pixel = this.gridToPixel(clickedToken.x, clickedToken.y);
                    this.dragOffset = {
                        x: mouse.x - pixel.x,
                        y: mouse.y - pixel.y
                    };
                    
                    // Update token selection
                    this.tokens.forEach(token => token.selected = false);
                    clickedToken.selected = true;
                } else if (this.measurementMode) {
                    // Start measurement
                    this.measurementLine = {
                        start: grid,
                        end: grid
                    };
                }
            }
            
            handleMouseMove(event) {
                const mouse = this.getMousePosition(event);
                const grid = this.pixelToGrid(mouse.x, mouse.y);
                
                if (this.isDragging && this.selectedToken) {
                    // Update drag preview
                    this.selectedToken.dragX = grid.x;
                    this.selectedToken.dragY = grid.y;
                } else if (this.measurementLine) {
                    // Update measurement line
                    this.measurementLine.end = grid;
                }
            }
            
            handleMouseUp(event) {
                if (this.isDragging && this.selectedToken) {
                    const mouse = this.getMousePosition(event);
                    const grid = this.pixelToGrid(mouse.x, mouse.y);
                    
                    // Validate and execute move
                    if (this.isValidMove(this.selectedToken, grid.x, grid.y)) {
                        this.moveToken(this.selectedToken, grid.x, grid.y);
                    }
                    
                    this.selectedToken.dragX = undefined;
                    this.selectedToken.dragY = undefined;
                }
                
                this.isDragging = false;
            }
            
            // ===== TOKEN MANAGEMENT =====
            addToken(participant) {
                const token = {
                    participant: participant,
                    x: participant.position.x,
                    y: participant.position.y,
                    label: this.generateTokenLabel(participant),
                    color: this.getTokenColor(participant),
                    selected: false
                };
                
                this.tokens.set(participant.id, token);
                return token;
            }
            
            generateTokenLabel(participant) {
                const name = participant.creature.name;
                if (name.length <= 3) return name;
                
                // Generate initials
                const words = name.split(' ');
                if (words.length > 1) {
                    return words.map(word => word[0]).join('').substring(0, 3);
                }
                return name.substring(0, 3);
            }
            
            getTokenAtPosition(x, y) {
                for (let token of this.tokens.values()) {
                    if (token.x === x && token.y === y) {
                        return token;
                    }
                }
                return null;
            }
            
            moveToken(token, newX, newY) {
                const oldX = token.x;
                const oldY = token.y;
                
                // Validate movement with combat system first
                if (this.combatManager) {
                    const isValid = this.combatManager.validateMovement(token.participant, oldX, oldY, newX, newY);
                    if (!isValid) {
                        return false; // Movement not allowed
                    }
                }
                
                token.x = newX;
                token.y = newY;
                token.participant.position.x = newX;
                token.participant.position.y = newY;
                
                return true;
            }
            
            setCombatManager(combatManager) {
                this.combatManager = combatManager;
            }
            
            isValidMove(token, newX, newY) {
                // Basic bounds checking
                if (newX < 0 || newX >= this.width || newY < 0 || newY >= this.height) {
                    return false;
                }
                
                // Check for token collision
                const existingToken = this.getTokenAtPosition(newX, newY);
                if (existingToken && existingToken !== token) {
                    return false;
                }
                
                return true;
            }
            
            // ===== TEMPLATE SYSTEM =====
            addTemplate(type, centerX, centerY, size, color = 'rgba(255, 0, 0, 0.3)') {
                const template = {
                    id: Date.now() + Math.random(),
                    type: type, // 'circle', 'cone', 'line', 'cube'
                    centerX: centerX,
                    centerY: centerY,
                    size: size,
                    color: color,
                    duration: -1 // -1 for permanent, positive for temporary
                };
                
                this.activeTemplates.push(template);
                return template;
            }
            
            drawTemplates() {
                this.activeTemplates.forEach(template => {
                    this.ctx.fillStyle = template.color;
                    this.ctx.strokeStyle = template.color.replace('0.3', '0.8');
                    this.ctx.lineWidth = 2;
                    
                    const centerPixel = this.gridToPixel(template.centerX, template.centerY);
                    
                    switch (template.type) {
                        case 'circle':
                            this.ctx.beginPath();
                            this.ctx.arc(centerPixel.x, centerPixel.y, template.size * this.cellSize, 0, 2 * Math.PI);
                            this.ctx.fill();
                            this.ctx.stroke();
                            break;
                            
                        case 'cube':
                            const halfSize = template.size * this.cellSize / 2;
                            this.ctx.fillRect(
                                centerPixel.x - halfSize,
                                centerPixel.y - halfSize,
                                template.size * this.cellSize,
                                template.size * this.cellSize
                            );
                            this.ctx.strokeRect(
                                centerPixel.x - halfSize,
                                centerPixel.y - halfSize,
                                template.size * this.cellSize,
                                template.size * this.cellSize
                            );
                            break;
                    }
                });
            }
            
            clearTemplates() {
                this.activeTemplates = [];
            }
            
            // ===== MEASUREMENT SYSTEM =====
            drawMeasurement() {
                if (this.measurementLine) {
                    const startPixel = this.gridToPixel(this.measurementLine.start.x, this.measurementLine.start.y);
                    const endPixel = this.gridToPixel(this.measurementLine.end.x, this.measurementLine.end.y);
                    
                    // Draw line
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(startPixel.x, startPixel.y);
                    this.ctx.lineTo(endPixel.x, endPixel.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // Calculate and display distance
                    const distance = this.calculateDistance(
                        this.measurementLine.start.x, this.measurementLine.start.y,
                        this.measurementLine.end.x, this.measurementLine.end.y
                    );
                    
                    const midPixel = {
                        x: (startPixel.x + endPixel.x) / 2,
                        y: (startPixel.y + endPixel.y) / 2
                    };
                    
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(midPixel.x - 20, midPixel.y - 10, 40, 20);
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.font = '12px bold sans-serif';
                    this.ctx.fillText(`${distance}ft`, midPixel.x, midPixel.y);
                }
            }
            
            calculateDistance(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                
                // Use combat settings for diagonal movement rules
                const useAdvancedDiagonals = combat?.settings?.advancedDiagonals || false;
                
                if (!useAdvancedDiagonals) {
                    // Simple rule: all movement costs 5ft per square (most common)
                    return Math.max(dx, dy) * 5;
                } else {
                    // Advanced rule: alternating 5/10ft diagonal cost
                    const straight = Math.abs(dx - dy);
                    const diagonal = Math.min(dx, dy);
                    const diagonalCost = Math.floor(diagonal / 2) * 15 + (diagonal % 2) * 5;
                    return (straight * 5 + diagonalCost); // straight is in squares, must multiply by 5ft
                }
            }
            
            // ===== ANIMATION SYSTEM =====
            startRenderLoop() {
                const animate = () => {
                    this.render();
                    requestAnimationFrame(animate);
                };
                animate();
            }
            
            updateAnimations() {
                this.animations = this.animations.filter(animation => {
                    animation.frame++;
                    return animation.frame < animation.duration;
                });
            }
            
            // ===== EVENT HANDLERS =====
            handleClick(event) {
                // Handle single clicks for selection
            }
            
            handleRightClick(event) {
                event.preventDefault();
                // Handle context menu
            }
            
            handleKeyDown(event) {
                switch (event.key) {
                    case 'm':
                        this.measurementMode = !this.measurementMode;
                        if (!this.measurementMode) {
                            this.measurementLine = null;
                        }
                        break;
                    case 'Escape':
                        this.selectedToken = null;
                        this.measurementMode = false;
                        this.measurementLine = null;
                        this.clearTemplates();
                        break;
                }
            }
            
            drawSelectionHighlight() {
                if (this.selectedToken) {
                    const pixel = this.gridToPixel(this.selectedToken.x, this.selectedToken.y);
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([10, 5]);
                    this.ctx.strokeRect(
                        this.selectedToken.x * this.cellSize,
                        this.selectedToken.y * this.cellSize,
                        this.cellSize,
                        this.cellSize
                    );
                    this.ctx.setLineDash([]);
                }
            }
            
            drawHighlights() {
                this.highlights.forEach((color, position) => {
                    const [x, y] = position.split(',').map(Number);
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
                });
            }
        }
        
        // ===== ADVANCED REAL-TIME COMBAT SYSTEM =====
        class CombatManager {
            constructor() {
                this.participants = [];
                this.round = 0;
                this.currentTurn = 0;
                this.isActive = false;
                this.surpriseRound = false;
                this.turnTimer = null;
                this.concentrationSpells = new Map(); // Track concentration spells
                
                // Combat Settings for Rule Variants
                this.settings = {
                    advancedDiagonals: false, // false = 5ft per diagonal, true = 5/10ft alternating
                    criticalDeathSaves: true, // Enable critical hit rules for death saves
                    massiveDamageThreshold: true // Enable massive damage instant death
                };
                
                // Initialize Interactive Battle Map System
                this.battleMap = new BattleMapRenderer();
                this.selectedToken = null;
                this.draggedToken = null;
                this.measurementMode = false;
                this.measurementStart = null;
            }
            
            // ===== RESOURCE CALCULATION METHODS =====
            calculateSpellSlots(creature, isPlayer) {
                // Return appropriate spell slots based on class and level
                if (!isPlayer || !creature.class || !creature.level) {
                    return {}; // Non-player creatures and NPCs don't get spell slots unless explicitly defined
                }
                
                const level = creature.level;
                const characterClass = creature.class.toLowerCase();
                
                // Full casters (Wizard, Sorcerer, Bard, Cleric, Druid)
                const fullCasterSlots = {
                    1: [2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                    2: [0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    3: [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    4: [0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    5: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3],
                    6: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3],
                    7: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3],
                    8: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2],
                    9: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
                };
                
                // Half casters (Ranger, Paladin)
                const halfCasterSlots = {
                    1: [0, 0, 2, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                    2: [0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    3: [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    4: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 3, 3, 3],
                    5: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3]
                };
                
                // Third casters (Eldritch Knight, Arcane Trickster)
                const thirdCasterSlots = {
                    1: [0, 0, 0, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
                    2: [0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    3: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3],
                    4: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]
                };
                
                if (['wizard', 'sorcerer', 'bard', 'cleric', 'druid'].includes(characterClass)) {
                    return this.getSlotsForLevel(fullCasterSlots, level);
                } else if (['ranger', 'paladin'].includes(characterClass)) {
                    return this.getSlotsForLevel(halfCasterSlots, level);
                } else if (['eldritch knight', 'arcane trickster'].includes(characterClass)) {
                    return this.getSlotsForLevel(thirdCasterSlots, level);
                } else if (characterClass === 'warlock') {
                    // Warlock spell slots work differently (Pact Magic)
                    const warlockLevel = Math.min(level, 20);
                    const slotLevel = Math.min(Math.ceil(warlockLevel / 2), 5);
                    const slotCount = warlockLevel < 2 ? 1 : warlockLevel < 11 ? 2 : warlockLevel < 17 ? 3 : 4;
                    return {[slotLevel]: slotCount};
                }
                
                return {}; // Non-caster classes
            }
            
            getSlotsForLevel(slotTable, level) {
                const slots = {};
                const levelIndex = Math.min(level - 1, 19); // Level 1 = index 0, cap at 20
                
                for (let spellLevel = 1; spellLevel <= 9; spellLevel++) {
                    const slotCount = slotTable[spellLevel]?.[levelIndex] || 0;
                    if (slotCount > 0) {
                        slots[spellLevel] = slotCount;
                    }
                }
                
                return slots;
            }
            
            addParticipant(creature, initiative = 0, isPlayer = false) {
                const participant = {
                    id: Date.now() + Math.random(),
                    creature: creature,
                    initiative: initiative,
                    hp: creature.hp !== undefined ? creature.hp : creature.maxHp,
                    maxHp: creature.maxHp || creature.hp || 1,
                    tempHp: 0,
                    
                    // Action Economy Tracking
                    actionUsed: false,
                    bonusActionUsed: false,
                    reactionUsed: false,
                    movementUsed: 0,
                    freeObjectInteractionUsed: false,
                    
                    // Advanced Combat State
                    conditions: [],
                    position: this.getNextAvailablePosition(),
                    previousPosition: {x: 0, y: 0},
                    facingDirection: 0, // 0-359 degrees
                    
                    // Resource Management (Preserve existing or calculate based on class/level)
                    spellSlots: creature.spellSlots || this.calculateSpellSlots(creature, isPlayer),
                    usedSpellSlots: {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0},
                    classAbilities: new Map(),
                    exhaustionLevel: 0,
                    deathSaves: {successes: 0, failures: 0},
                    stabilized: false,
                    
                    // Equipment & Inventory
                    equippedWeapons: [],
                    equippedArmor: null,
                    inventory: [],
                    encumbrance: 0,
                    carryingCapacity: (creature.abilities?.str || 10) * 15,
                    
                    // Combat Modifiers
                    advantageConditions: [],
                    disadvantageConditions: [],
                    damageResistances: creature.resistances || [],
                    damageImmunities: creature.immunities || [],
                    damageVulnerabilities: creature.vulnerabilities || [],
                    
                    // Advanced Tracking
                    concentratingOn: null,
                    heldAction: null,
                    readiedTrigger: null,
                    isPlayer: isPlayer,
                    turnStartEffects: [],
                    turnEndEffects: []
                };
                
                this.participants.push(participant);
                this.sortByInitiative();
                
                // Add token to battle map
                if (this.battleMap && this.battleMap.addToken) {
                    this.battleMap.addToken(participant);
                }
                
                this.logAction(`${creature.name} joins combat!`);
                return participant;
            }
            
            sortByInitiative() {
                this.participants.sort((a, b) => b.initiative - a.initiative);
            }
            
            getNextAvailablePosition() {
                // Define the battle map size (20x20 grid)
                const gridSize = 20;
                
                // Find next available position starting from top-left
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const occupied = this.participants.some(p => 
                            p.position && p.position.x === x && p.position.y === y
                        );
                        if (!occupied) {
                            return {x: x, y: y};
                        }
                    }
                }
                
                // Fallback to random position if grid is full (shouldn't happen normally)
                return {
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize)
                };
            }
            
            // ===== ADVANCED TURN MANAGEMENT =====
            nextTurn() {
                if (this.participants.length === 0) return;
                
                // Process end-of-turn effects for current participant
                if (this.participants[this.currentTurn]) {
                    this.processEndOfTurnEffects(this.participants[this.currentTurn]);
                }
                
                this.currentTurn++;
                if (this.currentTurn >= this.participants.length) {
                    this.currentTurn = 0;
                    this.round++;
                    this.processEndOfRoundEffects();
                }
                
                // Process start-of-turn effects for new current participant
                if (this.participants[this.currentTurn]) {
                    this.processStartOfTurnEffects(this.participants[this.currentTurn]);
                }
                
                this.updateUI();
                this.logAction(`Round ${this.round}, Turn ${this.currentTurn + 1}: ${this.participants[this.currentTurn]?.creature.name}'s turn`);
            }
            
            processStartOfTurnEffects(participant) {
                // Reset actions and movement
                participant.actionUsed = false;
                participant.bonusActionUsed = false;
                participant.reactionUsed = false;
                participant.movementUsed = 0;
                participant.freeObjectInteractionUsed = false;
                participant.previousPosition = {...participant.position};
                
                // Process death saving throws if unconscious at 0 HP
                if (participant.hp <= 0 && !participant.stabilized) {
                    this.rollDeathSave(participant);
                }
                
                // Process regeneration and ongoing effects
                this.processConditionEffects(participant, 'startOfTurn');
                
                // Process held actions from other participants
                this.checkHeldActionTriggers('startOfTurn', participant);
                
                // Apply exhaustion effects
                this.applyExhaustionEffects(participant);
            }
            
            processEndOfTurnEffects(participant) {
                // Process condition durations and effects
                this.processConditionEffects(participant, 'endOfTurn');
                
                // Check concentration if applicable
                if (participant.concentratingOn) {
                    this.checkConcentrationMaintenance(participant);
                }
            }
            
            processEndOfRoundEffects() {
                // Process effects that trigger at end of round
                this.participants.forEach(participant => {
                    // Reduce condition durations
                    participant.conditions = participant.conditions.filter(condition => {
                        if (condition.duration > 0) {
                            condition.duration--;
                            if (condition.duration === 0) {
                                this.logAction(`${participant.creature.name} is no longer ${condition.name}`);
                                this.removeConditionEffects(participant, condition);
                                return false;
                            }
                        }
                        return true;
                    });
                });
            }
            
            // ===== ADVANCED MOVEMENT SYSTEM =====
            moveParticipant(participantId, newX, newY, isDash = false) {
                const participant = this.participants.find(p => p.id === participantId);
                if (!participant) return false;
                
                const oldX = participant.position.x;
                const oldY = participant.position.y;
                const distance = this.calculateDistance(oldX, oldY, newX, newY);
                
                // Calculate available movement
                let availableMovement = this.calculateAvailableMovement(participant);
                if (isDash) {
                    availableMovement *= 2;
                    participant.actionUsed = true;
                }
                
                // Check if movement is valid
                if (participant.movementUsed + distance > availableMovement) {
                    this.logAction(`${participant.creature.name} doesn't have enough movement. Needs ${distance}ft, has ${availableMovement - participant.movementUsed}ft remaining.`);
                    return false;
                }
                
                // Check for opportunity attacks
                this.checkOpportunityAttacks(participant, oldX, oldY, newX, newY);
                
                // Apply movement
                participant.position.x = newX;
                participant.position.y = newY;
                participant.movementUsed += distance;
                
                // Check difficult terrain
                const terrainMultiplier = this.getTerrainMultiplier(newX, newY);
                if (terrainMultiplier > 1) {
                    participant.movementUsed += distance * (terrainMultiplier - 1);
                    this.logAction(`${participant.creature.name} moves through difficult terrain (${terrainMultiplier}x cost)`);
                }
                
                this.logAction(`${participant.creature.name} moves ${distance}ft to (${newX}, ${newY}). ${availableMovement - participant.movementUsed}ft movement remaining.`);
                this.updateUI();
                return true;
            }
            
            calculateDistance(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                
                // Use combat settings for diagonal movement rules
                const useAdvancedDiagonals = this.settings?.advancedDiagonals || false;
                
                if (!useAdvancedDiagonals) {
                    // Simple rule: all movement costs 5ft per square (most common)
                    return Math.max(dx, dy) * 5;
                } else {
                    // Advanced rule: alternating 5/10ft diagonal cost
                    const straight = Math.abs(dx - dy);
                    const diagonal = Math.min(dx, dy);
                    const diagonalCost = Math.floor(diagonal / 2) * 15 + (diagonal % 2) * 5;
                    return (straight * 5 + diagonalCost); // straight is in squares, must multiply by 5ft
                }
            }
            
            calculateAvailableMovement(participant) {
                let baseSpeed = participant.creature.speed?.walk || 30;
                
                // Apply condition effects
                if (this.hasCondition(participant, 'Grappled') || this.hasCondition(participant, 'Restrained')) {
                    return 0;
                }
                
                if (this.hasCondition(participant, 'Prone')) {
                    return Math.floor(baseSpeed / 2); // Crawling
                }
                
                // Apply exhaustion effects
                if (participant.exhaustionLevel >= 2) {
                    baseSpeed = Math.floor(baseSpeed / 2);
                }
                
                if (participant.exhaustionLevel >= 5) {
                    return 0;
                }
                
                return baseSpeed;
            }
            
            checkOpportunityAttacks(movingParticipant, oldX, oldY, newX, newY) {
                this.participants.forEach(participant => {
                    if (participant === movingParticipant || participant.hp <= 0) return;
                    if (participant.reactionUsed) return;
                    
                    const wasInReach = this.calculateDistance(participant.position.x, participant.position.y, oldX, oldY) <= 5;
                    const stillInReach = this.calculateDistance(participant.position.x, participant.position.y, newX, newY) <= 5;
                    
                    if (wasInReach && !stillInReach) {
                        // Opportunity attack triggered
                        this.logAction(`${participant.creature.name} gets an opportunity attack against ${movingParticipant.creature.name}!`);
                        
                        if (!movingParticipant.isPlayer) {
                            // Auto-resolve for NPCs
                            const actions = participant.creature.actions || [];
                            if (actions.length > 0) {
                                const meleeActions = actions.filter(a => a.attack && !a.attack.range);
                                if (meleeActions.length > 0) {
                                    this.executeAttack(participant, movingParticipant, meleeActions[0]);
                                    participant.reactionUsed = true;
                                }
                            }
                        }
                    }
                });
            }
            
            // ===== CONDITION MANAGEMENT SYSTEM =====
            addCondition(participant, conditionName, duration = -1, source = null) {
                const conditionData = DND_DATA.conditions[conditionName];
                if (!conditionData) {
                    this.logAction(`Unknown condition: ${conditionName}`);
                    return false;
                }
                
                // Check if already has condition
                if (this.hasCondition(participant, conditionName)) {
                    // Update duration if longer
                    const existing = participant.conditions.find(c => c.name === conditionName);
                    if (duration > existing.duration) {
                        existing.duration = duration;
                        existing.source = source;
                    }
                    return true;
                }
                
                const condition = {
                    name: conditionName,
                    duration: duration,
                    source: source,
                    data: conditionData
                };
                
                participant.conditions.push(condition);
                this.applyConditionEffects(participant, condition);
                this.logAction(`${participant.creature.name} is now ${conditionName}${duration > 0 ? ` for ${duration} rounds` : ''}`);
                return true;
            }
            
            removeCondition(participant, conditionName) {
                const index = participant.conditions.findIndex(c => c.name === conditionName);
                if (index !== -1) {
                    const condition = participant.conditions[index];
                    participant.conditions.splice(index, 1);
                    this.removeConditionEffects(participant, condition);
                    this.logAction(`${participant.creature.name} is no longer ${conditionName}`);
                    return true;
                }
                return false;
            }
            
            hasCondition(participant, conditionName) {
                return participant.conditions.some(c => c.name === conditionName);
            }
            
            applyConditionEffects(participant, condition) {
                // Apply immediate effects of conditions
                switch (condition.name) {
                    case 'Unconscious':
                        participant.hp = Math.min(0, participant.hp);
                        break;
                    case 'Paralyzed':
                    case 'Stunned':
                        // These prevent actions
                        break;
                    case 'Exhaustion':
                        // Handle exhaustion levels
                        break;
                }
            }
            
            removeConditionEffects(participant, condition) {
                // Remove effects when condition ends
                // Most effects are checked dynamically, so minimal cleanup needed
            }
            
            processConditionEffects(participant, timing) {
                participant.conditions.forEach(condition => {
                    this.processSpecificConditionEffect(participant, condition, timing);
                });
            }
            
            processSpecificConditionEffect(participant, condition, timing) {
                // Process condition effects based on timing (startOfTurn, endOfTurn, etc.)
                switch (condition.name) {
                    case 'Poisoned':
                        if (timing === 'startOfTurn' && condition.data.damage) {
                            this.dealDamage(participant, condition.data.damage, 'poison', 'Poison effect');
                        }
                        break;
                    case 'Burning':
                        if (timing === 'startOfTurn') {
                            this.dealDamage(participant, '1d6', 'fire', 'Fire damage');
                        }
                        break;
                }
            }
            
            // ===== DEATH SAVING THROWS =====
            rollDeathSave(participant) {
                if (participant.hp > 0 || participant.stabilized) return;
                
                const roll = rollDice(20).total;
                const isSuccess = roll >= 10;
                const isCritical = roll === 20 || roll === 1;
                
                if (roll === 20) {
                    // Critical success - regain 1 HP
                    participant.hp = 1;
                    participant.deathSaves = {successes: 0, failures: 0};
                    this.removeCondition(participant, 'Unconscious');
                    this.logAction(`${participant.creature.name} rolls a 20 on death save! Regains consciousness with 1 HP!`);
                } else if (roll === 1) {
                    // Critical failure - 2 failures
                    participant.deathSaves.failures += 2;
                    this.logAction(`${participant.creature.name} rolls a 1 on death save! Critical failure (2 failures)!`);
                } else if (isSuccess) {
                    participant.deathSaves.successes++;
                    this.logAction(`${participant.creature.name} succeeds death save (${roll}). Successes: ${participant.deathSaves.successes}/3`);
                } else {
                    participant.deathSaves.failures++;
                    this.logAction(`${participant.creature.name} fails death save (${roll}). Failures: ${participant.deathSaves.failures}/3`);
                }
                
                // Check for stabilization or death
                if (participant.deathSaves.successes >= 3) {
                    participant.stabilized = true;
                    participant.deathSaves = {successes: 0, failures: 0};
                    this.removeCondition(participant, 'Unconscious');
                    this.addCondition(participant, 'Stable');
                    this.logAction(`💚 ${participant.creature.name} is stabilized!`);
                } else if (participant.deathSaves.failures >= 3) {
                    this.logAction(`💀 ${participant.creature.name} has died!`);
                    this.addCondition(participant, 'Dead');
                    
                    // Remove dead participant from combat after a brief delay for dramatic effect
                    setTimeout(() => {
                        this.removeDeadParticipant(participant);
                    }, 2000);
                }
            }
            
            // ===== DEAD PARTICIPANT REMOVAL =====
            removeDeadParticipant(participant) {
                const participantIndex = this.participants.indexOf(participant);
                if (participantIndex === -1) return;
                
                this.logAction(`⚰️ ${participant.creature.name} is removed from combat.`);
                
                // Remove from battle map
                if (this.battleMap && this.battleMap.tokens) {
                    this.battleMap.tokens.delete(participant.id);
                    this.battleMap.draw();
                }
                
                // Adjust current turn if necessary
                if (participantIndex <= this.currentTurn) {
                    this.currentTurn = Math.max(0, this.currentTurn - 1);
                }
                
                // Remove participant from combat
                this.participants.splice(participantIndex, 1);
                
                // Check if combat should end
                this.checkCombatEnd();
                
                this.updateUI();
            }
            
            checkCombatEnd() {
                const alivePlayers = this.participants.filter(p => p.isPlayer && p.hp > 0);
                const aliveEnemies = this.participants.filter(p => !p.isPlayer && p.hp > 0);
                
                if (alivePlayers.length === 0) {
                    this.logAction(`💀 All players have fallen! Combat ends in defeat.`);
                    this.endCombat('defeat');
                } else if (aliveEnemies.length === 0) {
                    this.logAction(`🏆 All enemies have been defeated! Combat ends in victory!`);
                    this.endCombat('victory');
                }
            }
            
            endCombat(result) {
                this.isActive = false;
                this.currentTurn = 0;
                this.round = 0;
                
                // Reset all participants' combat-specific states
                this.participants.forEach(participant => {
                    if (participant.hp > 0) {
                        participant.actionUsed = false;
                        participant.bonusActionUsed = false;
                        participant.reactionUsed = false;
                        participant.movementUsed = 0;
                        participant.freeObjectInteractionUsed = false;
                        participant.conditions = participant.conditions?.filter(c => !['Stable', 'Unconscious'].includes(c)) || [];
                    }
                });
                
                this.logAction(`🎭 Combat has ended with ${result}!`);
                this.updateUI();
            }
            
            // ===== INVENTORY AND ENCUMBRANCE SYSTEM =====
            addItemToInventory(participant, item) {
                if (!participant.inventory) participant.inventory = [];
                
                // Add item with proper weight tracking
                const inventoryItem = {
                    id: Date.now() + Math.random(),
                    name: item.name,
                    weight: item.weight || 0,
                    quantity: item.quantity || 1,
                    type: item.type || 'misc',
                    description: item.description || '',
                    value: item.value || 0,
                    equipped: false
                };
                
                participant.inventory.push(inventoryItem);
                this.updateEncumbrance(participant);
                this.logAction(`📦 ${participant.creature.name} adds ${inventoryItem.name} to inventory.`);
                return inventoryItem;
            }
            
            removeItemFromInventory(participant, itemId, quantity = 1) {
                if (!participant.inventory) return false;
                
                const itemIndex = participant.inventory.findIndex(item => item.id === itemId);
                if (itemIndex === -1) return false;
                
                const item = participant.inventory[itemIndex];
                const itemName = item.name;
                
                if (item.quantity <= quantity) {
                    // Remove entirely
                    participant.inventory.splice(itemIndex, 1);
                    this.logAction(`📤 ${participant.creature.name} removes ${itemName} from inventory.`);
                } else {
                    // Reduce quantity
                    item.quantity -= quantity;
                    this.logAction(`📤 ${participant.creature.name} removes ${quantity} ${itemName} from inventory.`);
                }
                
                this.updateEncumbrance(participant);
                return true;
            }
            
            updateEncumbrance(participant) {
                if (!participant.inventory) participant.inventory = [];
                
                // Calculate total weight
                const totalWeight = participant.inventory.reduce((weight, item) => {
                    return weight + (item.weight * item.quantity);
                }, 0);
                
                participant.encumbrance = totalWeight;
                
                // Calculate carrying capacity (Strength * 15 lbs in D&D 5e)
                const strength = participant.creature.abilities?.str || 10;
                participant.carryingCapacity = strength * 15;
                
                // Apply encumbrance effects based on D&D 5e rules
                const encumbranceRatio = totalWeight / participant.carryingCapacity;
                
                if (encumbranceRatio >= 1) {
                    // Over carrying capacity - heavily encumbered
                    participant.speed = Math.max(5, (participant.creature.speed || 30) - 20);
                    participant.encumbranceLevel = 'overloaded';
                    this.addCondition(participant, 'Heavily Encumbered');
                } else if (encumbranceRatio >= 0.5) {
                    // Over half capacity - lightly encumbered (variant rule)
                    participant.speed = Math.max(10, (participant.creature.speed || 30) - 10);
                    participant.encumbranceLevel = 'encumbered';
                    this.addCondition(participant, 'Encumbered');
                } else {
                    // Normal carrying capacity
                    participant.speed = participant.creature.speed || 30;
                    participant.encumbranceLevel = 'normal';
                    this.removeCondition(participant, 'Heavily Encumbered');
                    this.removeCondition(participant, 'Encumbered');
                }
                
                this.updateUI();
            }
            
            equipItem(participant, itemId) {
                if (!participant.inventory) return false;
                
                const item = participant.inventory.find(item => item.id === itemId);
                if (!item) return false;
                
                // Handle different equipment types
                switch (item.type) {
                    case 'weapon':
                        if (!participant.equippedWeapons) participant.equippedWeapons = [];
                        if (participant.equippedWeapons.length >= 2) {
                            this.logAction(`⚠️ ${participant.creature.name} already has 2 weapons equipped.`);
                            return false;
                        }
                        participant.equippedWeapons.push(item);
                        break;
                    case 'armor':
                        if (participant.equippedArmor) {
                            this.logAction(`⚠️ ${participant.creature.name} already has armor equipped.`);
                            return false;
                        }
                        participant.equippedArmor = item;
                        break;
                    case 'shield':
                        if (participant.equippedShield) {
                            this.logAction(`⚠️ ${participant.creature.name} already has a shield equipped.`);
                            return false;
                        }
                        participant.equippedShield = item;
                        break;
                }
                
                item.equipped = true;
                this.logAction(`⚔️ ${participant.creature.name} equips ${item.name}.`);
                this.updateUI();
                return true;
            }
            
            unequipItem(participant, itemId) {
                if (!participant.inventory) return false;
                
                const item = participant.inventory.find(item => item.id === itemId);
                if (!item || !item.equipped) return false;
                
                // Remove from equipped slots
                switch (item.type) {
                    case 'weapon':
                        participant.equippedWeapons = participant.equippedWeapons?.filter(w => w.id !== itemId) || [];
                        break;
                    case 'armor':
                        participant.equippedArmor = null;
                        break;
                    case 'shield':
                        participant.equippedShield = null;
                        break;
                }
                
                item.equipped = false;
                this.logAction(`🎒 ${participant.creature.name} unequips ${item.name}.`);
                this.updateUI();
                return true;
            }
            
            getInventoryWeight(participant) {
                if (!participant.inventory) return 0;
                return participant.inventory.reduce((weight, item) => {
                    return weight + (item.weight * item.quantity);
                }, 0);
            }
            
            getEncumbranceStatus(participant) {
                const weight = this.getInventoryWeight(participant);
                const capacity = participant.carryingCapacity || ((participant.creature.abilities?.str || 10) * 15);
                const ratio = weight / capacity;
                
                if (ratio >= 1) return { level: 'overloaded', penalty: 'Speed reduced by 20 feet, minimum 5 feet' };
                if (ratio >= 0.5) return { level: 'encumbered', penalty: 'Speed reduced by 10 feet, minimum 10 feet' };
                return { level: 'normal', penalty: 'No penalties' };
            }
            
            // ===== CONCENTRATION SYSTEM =====
            startConcentration(participant, spellName, duration) {
                // End any existing concentration
                if (participant.concentratingOn) {
                    this.endConcentration(participant);
                }
                
                participant.concentratingOn = {
                    spell: spellName,
                    duration: duration,
                    startRound: this.round
                };
                
                this.logAction(`${participant.creature.name} begins concentrating on ${spellName}`);
            }
            
            endConcentration(participant) {
                if (!participant.concentratingOn) return;
                
                const spellName = participant.concentratingOn.spell;
                participant.concentratingOn = null;
                this.logAction(`${participant.creature.name} stops concentrating on ${spellName}`);
            }
            
            checkConcentration(participant, damage) {
                if (!participant.concentratingOn) return true;
                
                const dc = Math.max(10, Math.floor(damage / 2));
                const conMod = calculateModifier(participant.creature.abilities?.con || 10);
                const proficiencyBonus = this.getProficiencyBonus(participant);
                
                // Check if proficient in Constitution saves
                const isProficient = participant.creature.saves?.includes('Constitution') || false;
                const bonus = conMod + (isProficient ? proficiencyBonus : 0);
                
                const roll = rollDice(20, 1, bonus);
                const success = roll.total >= dc;
                
                this.logAction(`${participant.creature.name} makes concentration save: ${roll.total} vs DC ${dc} - ${success ? 'SUCCESS' : 'FAILURE'}`);
                
                if (!success) {
                    this.endConcentration(participant);
                }
                
                return success;
            }
            
            checkConcentrationMaintenance(participant) {
                if (!participant.concentratingOn) return;
                
                // Check if spell duration has ended
                if (participant.concentratingOn.duration > 0) {
                    participant.concentratingOn.duration--;
                    if (participant.concentratingOn.duration === 0) {
                        this.endConcentration(participant);
                    }
                }
            }
            
            // ===== ADVANCED DAMAGE SYSTEM =====
            dealDamage(participant, damageAmount, damageType = 'bludgeoning', source = 'Unknown', isCritical = false, isMelee = false) {
                let damage = typeof damageAmount === 'string' ? this.rollDamage(damageAmount).total : damageAmount;
                
                // D&D 5e Rule: Taking damage at 0 HP causes death save failures
                if (participant.hp <= 0 && damage > 0) {
                    if (!participant.deathSaves) {
                        participant.deathSaves = {successes: 0, failures: 0};
                    }
                    
                    // RAW: Stabilized creatures lose stabilization when taking damage
                    if (participant.stabilized) {
                        participant.stabilized = false;
                        this.removeCondition(participant, 'Stable');
                        this.addCondition(participant, 'Unconscious');
                        this.logAction(`${participant.creature.name} loses stabilization from taking damage!`);
                    }
                    
                    // Any attack that hits from within 5 feet = 2 death save failures (auto-crit rule)
                    // For simplicity, treat isCritical as "attack from within 5 feet"
                    if (isCritical) {
                        participant.deathSaves.failures += 2;
                        this.logAction(`💀 ${participant.creature.name} takes an attack from within 5 feet while unconscious! 2 death save failures!`);
                    } else {
                        // Normal damage at 0 HP = 1 death save failure
                        participant.deathSaves.failures += 1;
                        this.logAction(`💀 ${participant.creature.name} takes damage while unconscious! 1 death save failure!`);
                    }
                    
                    // Check for death
                    if (participant.deathSaves.failures >= 3) {
                        this.logAction(`💀 ${participant.creature.name} has died!`);
                        this.addCondition(participant, 'Dead');
                        
                        // Remove dead participant from combat after a brief delay
                        setTimeout(() => {
                            this.removeDeadParticipant(participant);
                        }, 2000);
                    }
                    
                    this.updateUI();
                    return;
                }
                
                // Apply damage resistances, immunities, and vulnerabilities
                if (participant.damageImmunities.includes(damageType)) {
                    damage = 0;
                    this.logAction(`${participant.creature.name} is immune to ${damageType} damage`);
                } else if (participant.damageResistances.includes(damageType)) {
                    damage = Math.floor(damage / 2);
                    this.logAction(`${participant.creature.name} resists ${damageType} damage (halved)`);
                } else if (participant.damageVulnerabilities.includes(damageType)) {
                    damage *= 2;
                    this.logAction(`${participant.creature.name} is vulnerable to ${damageType} damage (doubled)`);
                }
                
                // Apply to temporary HP first
                if (participant.tempHp > 0) {
                    const tempDamage = Math.min(damage, participant.tempHp);
                    participant.tempHp -= tempDamage;
                    damage -= tempDamage;
                    this.logAction(`${tempDamage} damage absorbed by temporary HP`);
                }
                
                // Apply remaining damage to HP
                if (damage > 0) {
                    participant.hp -= damage;
                    this.logAction(`${participant.creature.name} takes ${damage} ${damageType} damage from ${source}`);
                    
                    // Check concentration if damaged
                    if (damage > 0 && participant.concentratingOn) {
                        this.checkConcentration(participant, damage);
                    }
                    
                    // Check for unconsciousness
                    if (participant.hp <= 0) {
                        this.handleUnconscious(participant, damage);
                    }
                }
                
                this.updateUI();
            }
            
            handleUnconscious(participant, excessDamage) {
                const maxHp = participant.maxHp;
                
                // Check for massive damage (instant death)
                if (excessDamage >= maxHp) {
                    this.logAction(`${participant.creature.name} takes massive damage and dies instantly!`);
                    this.addCondition(participant, 'Dead');
                    return;
                }
                
                // Set HP to 0 and add unconscious condition
                participant.hp = 0;
                participant.deathSaves = {successes: 0, failures: 0};
                participant.stabilized = false;
                this.addCondition(participant, 'Unconscious');
                
                this.logAction(`${participant.creature.name} falls unconscious!`);
            }
            
            // ===== EXHAUSTION SYSTEM =====
            addExhaustion(participant, levels = 1) {
                participant.exhaustionLevel = Math.min(6, participant.exhaustionLevel + levels);
                this.logAction(`${participant.creature.name} gains ${levels} level(s) of exhaustion (total: ${participant.exhaustionLevel})`);
                
                if (participant.exhaustionLevel >= 6) {
                    this.logAction(`${participant.creature.name} dies from exhaustion!`);
                    this.addCondition(participant, 'Dead');
                }
                
                this.applyExhaustionEffects(participant);
            }
            
            removeExhaustion(participant, levels = 1) {
                participant.exhaustionLevel = Math.max(0, participant.exhaustionLevel - levels);
                this.logAction(`${participant.creature.name} removes ${levels} level(s) of exhaustion (total: ${participant.exhaustionLevel})`);
                this.applyExhaustionEffects(participant);
            }
            
            applyExhaustionEffects(participant) {
                // Effects are applied dynamically based on exhaustion level
                const level = participant.exhaustionLevel;
                let effects = [];
                
                if (level >= 1) effects.push("Disadvantage on ability checks");
                if (level >= 2) effects.push("Speed halved");
                if (level >= 3) effects.push("Disadvantage on attack rolls and saving throws");
                if (level >= 4) effects.push("Hit point maximum halved");
                if (level >= 5) effects.push("Speed reduced to 0");
                if (level >= 6) effects.push("Death");
                
                if (effects.length > 0) {
                    this.logAction(`${participant.creature.name} exhaustion effects: ${effects.join(', ')}`);
                }
            }
            
            // ===== UTILITY METHODS =====
            getProficiencyBonus(participant) {
                // Estimate proficiency bonus based on creature type
                if (participant.creature.proficiencyBonus) {
                    return participant.creature.proficiencyBonus;
                }
                
                // Default calculation for player characters
                const level = participant.creature.level || 1;
                return Math.ceil(level / 4) + 1;
            }
            
            getTerrainMultiplier(x, y) {
                if (this.battleMap && this.battleMap.terrain) {
                    const terrain = this.battleMap.terrain.get(`${x},${y}`);
                    return terrain?.movementMultiplier || 1;
                }
                return 1;
            }
            
            // ===== BATTLE MAP INTEGRATION =====
            validateMovement(participant, oldX, oldY, newX, newY) {
                // Called by BattleMapRenderer when token is moved
                const distance = this.calculateDistance(oldX, oldY, newX, newY);
                const availableMovement = this.calculateAvailableMovement(participant);
                
                if (participant.movementUsed + distance > availableMovement) {
                    this.logAction(`${participant.creature.name} doesn't have enough movement. Needs ${distance}ft, has ${availableMovement - participant.movementUsed}ft remaining.`);
                    return false;
                }
                
                // Apply movement and check for opportunity attacks
                this.checkOpportunityAttacks(participant, oldX, oldY, newX, newY);
                participant.movementUsed += distance;
                
                this.logAction(`${participant.creature.name} moves ${distance}ft to (${newX}, ${newY}). ${availableMovement - participant.movementUsed}ft movement remaining.`);
                this.updateUI();
                return true;
            }
            
            syncParticipantsToMap() {
                // Sync all current participants to the battle map
                if (this.battleMap && this.battleMap.addToken) {
                    this.participants.forEach(participant => {
                        this.battleMap.addToken(participant);
                    });
                }
            }
            
            checkHeldActionTriggers(trigger, participant) {
                // Check if any held actions should trigger
                this.participants.forEach(holder => {
                    if (holder.heldAction && holder.readiedTrigger === trigger) {
                        this.logAction(`${holder.creature.name}'s held action triggers!`);
                        // Execute held action
                        holder.heldAction = null;
                        holder.readiedTrigger = null;
                    }
                });
            }
            
            
            // ===== SPELL SLOT MANAGEMENT =====
            useSpellSlot(participant, level) {
                if (!participant.spellSlots[level] || participant.usedSpellSlots[level] >= participant.spellSlots[level]) {
                    return false; // No available spell slots
                }
                
                participant.usedSpellSlots[level]++;
                this.logAction(`${participant.creature.name} uses a level ${level} spell slot (${participant.usedSpellSlots[level]}/${participant.spellSlots[level]} used)`);
                return true;
            }
            
            getAvailableSpellSlots(participant, level) {
                const total = participant.spellSlots[level] || 0;
                const used = participant.usedSpellSlots[level] || 0;
                return Math.max(0, total - used);
            }
            
            restoreSpellSlots(participant, restType = 'long') {
                if (restType === 'long') {
                    // Long rest restores all spell slots
                    participant.usedSpellSlots = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
                    this.logAction(`${participant.creature.name} recovers all spell slots from a long rest`);
                } else if (restType === 'short' && participant.creature.class?.toLowerCase() === 'warlock') {
                    // Warlocks recover spell slots on short rest
                    participant.usedSpellSlots = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
                    this.logAction(`${participant.creature.name} recovers warlock spell slots from a short rest`);
                }
            }
            
            processTurnEffects() {
                // Process condition durations, spell effects, etc.
                this.participants.forEach(participant => {
                    participant.conditions = participant.conditions.filter(condition => {
                        if (condition.duration > 0) {
                            condition.duration--;
                            return condition.duration > 0;
                        }
                        return false;
                    });
                });
            }
            
            updateUI() {
                this.updateInitiativeDisplay();
                this.updateActiveCreature();
                this.updateRoundCounter();
            }
            
            updateInitiativeDisplay() {
                const container = document.getElementById('initiative-list');
                container.innerHTML = '';
                
                this.participants.forEach((participant, index) => {
                    const div = document.createElement('div');
                    div.className = `creature-card p-3 rounded-md mb-2 ${index === this.currentTurn ? 'active' : ''}`;
                    
                    const hpPercent = (participant.hp / participant.maxHp) * 100;
                    
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <span class="font-bold">${participant.creature.name}</span>
                                <span class="text-sm text-gray-400 ml-2">(${participant.initiative})</span>
                            </div>
                            <div class="text-right">
                                <div class="text-sm">${participant.hp}/${participant.maxHp}</div>
                                <div class="w-16 bg-gray-700 rounded-full overflow-hidden">
                                    <div class="hp-bar" style="width: ${hpPercent}%"></div>
                                </div>
                            </div>
                        </div>
                        ${participant.conditions.length > 0 ? `
                            <div class="mt-2 flex flex-wrap gap-1">
                                ${participant.conditions.map(c => `<span class="bg-red-600 text-xs px-2 py-1 rounded">${c.name}</span>`).join('')}
                            </div>
                        ` : ''}
                    `;
                    
                    container.appendChild(div);
                });
            }
            
            updateActiveCreature() {
                const container = document.getElementById('active-creature-info');
                if (this.participants.length === 0 || this.currentTurn >= this.participants.length) {
                    container.innerHTML = '<p class="text-gray-400">No active creature</p>';
                    return;
                }
                
                const active = this.participants[this.currentTurn];
                const creature = active.creature;
                
                container.innerHTML = `
                    <div class="space-y-2">
                        <h3 class="font-bold text-xl">${creature.name}</h3>
                        <p class="text-sm text-gray-400">${creature.size} ${creature.type}</p>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div>AC: ${creature.ac}</div>
                            <div>Speed: ${creature.speed.walk}ft</div>
                            <div>HP: ${active.hp}/${active.maxHp}</div>
                            <div>Initiative: ${active.initiative}</div>
                        </div>
                        <div class="mt-2">
                            <div class="text-xs text-gray-400">Actions Available:</div>
                            <div class="text-xs">
                                Action: ${active.actionUsed ? '❌' : '✅'} | 
                                Bonus: ${active.bonusActionUsed ? '❌' : '✅'} | 
                                Reaction: ${active.reactionUsed ? '❌' : '✅'}
                            </div>
                            <div class="text-xs">Movement: ${active.movementUsed}/${creature.speed.walk}ft</div>
                        </div>
                    </div>
                `;
            }
            
            updateRoundCounter() {
                document.getElementById('round-counter').textContent = this.round;
                document.getElementById('turn-counter').textContent = this.currentTurn + 1;
            }
            
            rollInitiative() {
                this.participants.forEach(participant => {
                    const dexMod = calculateModifier(participant.creature.abilities?.dex || 10);
                    const roll = rollDice(20, 1, dexMod);
                    participant.initiative = roll.total;
                });
                this.sortByInitiative();
                this.round = 1;
                this.currentTurn = 0;
                this.isActive = true;
                this.updateUI();
                this.logAction(`Combat started! Initiative rolled.`);
            }
            
            // ===== ACTION ECONOMY VALIDATION SYSTEM =====
            validateAction(participant, actionType) {
                const validationResult = {
                    valid: true,
                    message: '',
                    actionType: actionType
                };
                
                switch (actionType) {
                    case 'action':
                        if (participant.actionUsed) {
                            validationResult.valid = false;
                            validationResult.message = `${participant.creature.name} has already used their Action this turn.`;
                        }
                        break;
                    case 'bonus_action':
                        if (participant.bonusActionUsed) {
                            validationResult.valid = false;
                            validationResult.message = `${participant.creature.name} has already used their Bonus Action this turn.`;
                        }
                        break;
                    case 'reaction':
                        if (participant.reactionUsed) {
                            validationResult.valid = false;
                            validationResult.message = `${participant.creature.name} has already used their Reaction this turn.`;
                        }
                        break;
                    case 'movement':
                        const speed = participant.creature.speed || 30;
                        if (participant.movementUsed >= speed) {
                            validationResult.valid = false;
                            validationResult.message = `${participant.creature.name} has already used all their movement (${speed} feet) this turn.`;
                        }
                        break;
                    case 'free_interaction':
                        if (participant.freeObjectInteractionUsed) {
                            validationResult.valid = false;
                            validationResult.message = `${participant.creature.name} has already used their free object interaction this turn.`;
                        }
                        break;
                }
                
                return validationResult;
            }
            
            useAction(participant, actionType, actionName = '') {
                const validation = this.validateAction(participant, actionType);
                
                if (!validation.valid) {
                    this.logAction(`⚠️ ${validation.message}`);
                    return false;
                }
                
                // Mark the action as used
                switch (actionType) {
                    case 'action':
                        participant.actionUsed = true;
                        this.logAction(`🎯 ${participant.creature.name} uses their Action${actionName ? ` to ${actionName}` : ''}.`);
                        break;
                    case 'bonus_action':
                        participant.bonusActionUsed = true;
                        this.logAction(`⚡ ${participant.creature.name} uses their Bonus Action${actionName ? ` to ${actionName}` : ''}.`);
                        break;
                    case 'reaction':
                        participant.reactionUsed = true;
                        this.logAction(`🛡️ ${participant.creature.name} uses their Reaction${actionName ? ` to ${actionName}` : ''}.`);
                        break;
                    case 'free_interaction':
                        participant.freeObjectInteractionUsed = true;
                        this.logAction(`🤏 ${participant.creature.name} uses their free object interaction${actionName ? ` to ${actionName}` : ''}.`);
                        break;
                }
                
                this.updateUI();
                return true;
            }
            
            autoAttack(participantIndex = this.currentTurn) {
                if (participantIndex >= this.participants.length) return;
                
                const attacker = this.participants[participantIndex];
                
                // Validate that the attacker can use their Action
                if (!this.useAction(attacker, 'action', 'attack')) {
                    return;
                }
                
                const targets = this.participants.filter(p => p !== attacker && p.hp > 0);
                
                if (targets.length === 0) {
                    this.logAction(`${attacker.creature.name} has no valid targets.`);
                    return;
                }
                
                const target = targets[Math.floor(Math.random() * targets.length)];
                const actions = attacker.creature.actions || [];
                
                if (actions.length === 0) {
                    this.logAction(`${attacker.creature.name} has no available attacks.`);
                    return;
                }
                
                const action = actions[Math.floor(Math.random() * actions.length)];
                this.executeAttack(attacker, target, action);
                // Action already consumed by useAction() above - no need to set again
            }
            
            executeAttack(attacker, target, action) {
                if (!action.attack) {
                    this.logAction(`${attacker.creature.name} uses ${action.name} on ${target.creature.name}.`);
                    return;
                }
                
                const attackRoll = rollDice(20, 1, action.attack.bonus);
                const hit = attackRoll.total >= target.creature.ac;
                
                if (hit) {
                    const damageRoll = this.rollDamage(action.attack.damage);
                    target.hp = Math.max(0, target.hp - damageRoll.total);
                    
                    this.logAction(`${attacker.creature.name} attacks ${target.creature.name} with ${action.name}. Rolls ${attackRoll.total} to hit (AC ${target.creature.ac}). HIT! Deals ${damageRoll.total} ${action.attack.damageType} damage.`);
                    
                    if (target.hp <= 0) {
                        this.logAction(`${target.creature.name} drops to 0 hit points!`);
                    }
                } else {
                    this.logAction(`${attacker.creature.name} attacks ${target.creature.name} with ${action.name}. Rolls ${attackRoll.total} to hit (AC ${target.creature.ac}). MISS!`);
                }
            }
            
            rollDamage(damageString) {
                // Parse damage strings like "1d8+3" or "2d6"
                const match = damageString.match(/(\d+)d(\d+)(?:\+(\d+))?/);
                if (!match) return {total: 1, rolls: [1]};
                
                const count = parseInt(match[1]);
                const sides = parseInt(match[2]);
                const modifier = parseInt(match[3] || 0);
                
                return rollDice(sides, count, modifier);
            }
            
            logAction(message) {
                const log = document.getElementById('combat-log');
                const timestamp = new Date().toLocaleTimeString();
                log.innerHTML += `<div class="text-sm"><span class="text-gray-400">[${timestamp}]</span> ${message}</div>`;
                log.scrollTop = log.scrollHeight;
            }
        }
        
        // Global combat manager instance
        const combat = new CombatManager();
        
        // Initialize battle map integration
        function initializeBattleMap() {
            if (combat && combat.battleMap && combat.battleMap.setCombatManager) {
                combat.battleMap.setCombatManager(combat);
                console.log('🗺️ Battle map integrated with combat system');
                
                // Sync any existing participants to the map
                combat.syncParticipantsToMap();
            }
        }
        
        // ===== EVENT LISTENERS =====
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize battle map integration
            setTimeout(() => {
                initializeBattleMap();
            }, 1000); // Wait for all systems to initialize
            
            // Tab switching
            document.querySelectorAll('[id^="tab-"]').forEach(button => {
                button.addEventListener('click', (e) => {
                    const tabName = e.target.id.replace('tab-', '');
                    showTab(tabName);
                });
            });
            
            // Combat controls
            document.getElementById('roll-initiative')?.addEventListener('click', () => {
                if (combat.participants.length === 0) {
                    // Add some test creatures for demo
                    combat.addParticipant(DND_DATA.monsters.Goblin);
                    combat.addParticipant(DND_DATA.monsters.Orc);
                    combat.addParticipant({
                        name: "Player Character",
                        hp: 25,
                        ac: 15,
                        abilities: {dex: 14},
                        speed: {walk: 30},
                        size: "Medium",
                        type: "humanoid"
                    });
                }
                combat.rollInitiative();
            });
            
            document.getElementById('next-turn')?.addEventListener('click', () => {
                combat.nextTurn();
            });
            
            document.getElementById('auto-attack')?.addEventListener('click', () => {
                combat.autoAttack();
            });
            
            // Fullscreen battle map functionality
            document.getElementById('fullscreen-map')?.addEventListener('click', () => {
                const battleMap = document.getElementById('battle-map');
                const exitBtn = document.getElementById('exit-fullscreen');
                
                battleMap.classList.add('fullscreen');
                exitBtn.classList.remove('hidden');
                
                // Resize canvas to fullscreen
                const canvas = document.getElementById('map-canvas');
                if (canvas && combat.battleMap) {
                    // Force canvas resize
                    setTimeout(() => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        combat.battleMap.draw();
                    }, 100);
                }
            });
            
            document.getElementById('exit-fullscreen')?.addEventListener('click', () => {
                const battleMap = document.getElementById('battle-map');
                const exitBtn = document.getElementById('exit-fullscreen');
                
                battleMap.classList.remove('fullscreen');
                exitBtn.classList.add('hidden');
                
                // Restore canvas size
                const canvas = document.getElementById('map-canvas');
                if (canvas && combat.battleMap) {
                    setTimeout(() => {
                        // Let CSS handle the sizing, then redraw
                        canvas.width = canvas.offsetWidth;
                        canvas.height = canvas.offsetHeight;
                        combat.battleMap.draw();
                    }, 100);
                }
            });
            
            // Handle ESC key to exit fullscreen
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const battleMap = document.getElementById('battle-map');
                    if (battleMap.classList.contains('fullscreen')) {
                        document.getElementById('exit-fullscreen').click();
                    }
                }
            });
            
            // ===== DICE ROLLING SYSTEM =====
            function setupDiceRoller() {
                const resultsDiv = document.getElementById('dice-results');
                
                document.querySelectorAll('.dice-btn[data-sides]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const sides = parseInt(btn.dataset.sides);
                        const result = rollDice(sides);
                        addDiceResult(`d${sides}`, result);
                    });
                });
                
                document.getElementById('dice-formula')?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        rollFormula();
                    }
                });
                
                document.getElementById('roll-advantage')?.addEventListener('click', () => {
                    const result1 = rollDice(20);
                    const result2 = rollDice(20);
                    const final = result1.total > result2.total ? result1 : result2;
                    addDiceResult('d20 (Advantage)', final, `Rolled: ${result1.total}, ${result2.total}`);
                });
                
                document.getElementById('roll-disadvantage')?.addEventListener('click', () => {
                    const result1 = rollDice(20);
                    const result2 = rollDice(20);
                    const final = result1.total < result2.total ? result1 : result2;
                    addDiceResult('d20 (Disadvantage)', final, `Rolled: ${result1.total}, ${result2.total}`);
                });
                
                document.getElementById('clear-results')?.addEventListener('click', () => {
                    resultsDiv.innerHTML = '';
                });
                
                function rollFormula() {
                    const formula = document.getElementById('dice-formula').value.trim();
                    if (!formula) return;
                    
                    try {
                        const result = parseAndRollFormula(formula);
                        addDiceResult(formula, result);
                    } catch (error) {
                        addDiceResult(formula, {total: 'Error', rolls: [], error: error.message});
                    }
                }
                
                function parseAndRollFormula(formula) {
                    // Handle formulas like "2d6+3", "1d20-1", "3d8"
                    const parts = formula.toLowerCase().match(/(\d+)d(\d+)([+-]\d+)?/g);
                    if (!parts) throw new Error('Invalid formula');
                    
                    let total = 0;
                    let allRolls = [];
                    
                    parts.forEach(part => {
                        const match = part.match(/(\d+)d(\d+)([+-]\d+)?/);
                        if (match) {
                            const count = parseInt(match[1]);
                            const sides = parseInt(match[2]);
                            const modifier = match[3] ? parseInt(match[3]) : 0;
                            
                            const result = rollDice(sides, count, modifier);
                            total += result.total;
                            allRolls.push(...result.rolls);
                        }
                    });
                    
                    return {total, rolls: allRolls};
                }
                
                function addDiceResult(formula, result, extra = '') {
                    const timestamp = new Date().toLocaleTimeString();
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'border-b border-gray-700 pb-2 mb-2';
                    
                    const isError = result.error;
                    const rollsText = result.rolls?.length ? ` (${result.rolls.join(', ')})` : '';
                    const extraText = extra ? ` - ${extra}` : '';
                    
                    resultDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <span class="font-bold ${isError ? 'text-red-400' : 'text-green-400'}">${formula}</span>
                            <span class="text-2xl ${isError ? 'text-red-400' : 'text-yellow-400'}">${result.total}</span>
                        </div>
                        <div class="text-xs text-gray-400">[${timestamp}] ${rollsText}${extraText}</div>
                        ${isError ? `<div class="text-xs text-red-400">${result.error}</div>` : ''}
                    `;
                    
                    resultsDiv.insertBefore(resultDiv, resultsDiv.firstChild);
                }
            }
            
            // ===== SPELL DATABASE SYSTEM =====
            function setupSpellDatabase() {
                const spellList = document.getElementById('spell-list');
                const spellDetails = document.getElementById('spell-details');
                const searchInput = document.getElementById('spell-search');
                const levelFilter = document.getElementById('spell-level-filter');
                const classFilter = document.getElementById('spell-class-filter');
                
                function getAllSpells() {
                    const allSpells = [];
                    
                    Object.entries(DND_DATA.spells.cantrips).forEach(([name, spell]) => {
                        allSpells.push({name, ...spell});
                    });
                    
                    Object.entries(DND_DATA.spells.level1).forEach(([name, spell]) => {
                        allSpells.push({name, ...spell});
                    });
                    
                    return allSpells;
                }
                
                function displaySpells(spells = getAllSpells()) {
                    spellList.innerHTML = '';
                    
                    spells.forEach(spell => {
                        const card = document.createElement('div');
                        card.className = 'card p-4 cursor-pointer hover:border-red-700 transition-colors';
                        card.innerHTML = `
                            <h4 class="font-bold text-lg">${spell.name}</h4>
                            <p class="text-sm text-gray-400">${spell.school} ${spell.level === 0 ? 'Cantrip' : `Level ${spell.level}`}</p>
                            <p class="text-xs text-gray-500 mt-1">${spell.classes?.join(', ') || 'Unknown'}</p>
                        `;
                        
                        card.addEventListener('click', () => {
                            displaySpellDetails(spell);
                        });
                        
                        spellList.appendChild(card);
                    });
                }
                
                function displaySpellDetails(spell) {
                    spellDetails.innerHTML = `
                        <div class="space-y-4">
                            <div>
                                <h3 class="font-title text-2xl text-red-400">${spell.name}</h3>
                                <p class="text-gray-400">${spell.school} ${spell.level === 0 ? 'cantrip' : `${spell.level}${getOrdinalSuffix(spell.level)}-level spell`}</p>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-4 text-sm">
                                <div><strong>Casting Time:</strong> ${spell.castingTime}</div>
                                <div><strong>Range:</strong> ${spell.range}</div>
                                <div><strong>Components:</strong> ${spell.components}</div>
                                <div><strong>Duration:</strong> ${spell.duration}</div>
                            </div>
                            
                            <div>
                                <strong>Classes:</strong> ${spell.classes?.join(', ') || 'Unknown'}
                            </div>
                            
                            <div>
                                <strong>Description:</strong>
                                <p class="mt-2 text-gray-300">${spell.description}</p>
                            </div>
                            
                            ${spell.damage ? `<div><strong>Damage:</strong> ${spell.damage} ${spell.damageType || ''}</div>` : ''}
                            ${spell.healing ? `<div><strong>Healing:</strong> ${spell.healing}</div>` : ''}
                            ${spell.attack ? `<div><strong>Attack:</strong> ${spell.attack} spell attack</div>` : ''}
                            ${spell.autoHit ? '<div class="text-green-400"><strong>Auto-hit spell</strong></div>' : ''}
                        </div>
                    `;
                }
                
                function getOrdinalSuffix(num) {
                    const j = num % 10;
                    const k = num % 100;
                    if (j == 1 && k != 11) return 'st';
                    if (j == 2 && k != 12) return 'nd';
                    if (j == 3 && k != 13) return 'rd';
                    return 'th';
                }
                
                function filterSpells() {
                    const searchTerm = searchInput.value.toLowerCase();
                    const levelFilter_val = levelFilter.value;
                    const classFilter_val = classFilter.value;
                    
                    let filtered = getAllSpells().filter(spell => {
                        const matchesSearch = spell.name.toLowerCase().includes(searchTerm) || 
                                            spell.description.toLowerCase().includes(searchTerm);
                        const matchesLevel = !levelFilter_val || spell.level.toString() === levelFilter_val;
                        const matchesClass = !classFilter_val || spell.classes?.includes(classFilter_val);
                        
                        return matchesSearch && matchesLevel && matchesClass;
                    });
                    
                    displaySpells(filtered);
                }
                
                searchInput?.addEventListener('input', filterSpells);
                levelFilter?.addEventListener('change', filterSpells);
                classFilter?.addEventListener('change', filterSpells);
                
                // Initial display
                displaySpells();
            }
            
            // ===== MONSTER DATABASE SYSTEM =====
            function setupMonsterDatabase() {
                const monsterList = document.getElementById('monster-list');
                const monsterDetails = document.getElementById('monster-details');
                const searchInput = document.getElementById('monster-search');
                const crFilter = document.getElementById('monster-cr-filter');
                const typeFilter = document.getElementById('monster-type-filter');
                
                function displayMonsters(monsters = Object.values(DND_DATA.monsters)) {
                    monsterList.innerHTML = '';
                    
                    monsters.forEach(monster => {
                        const card = document.createElement('div');
                        card.className = 'card p-4 cursor-pointer hover:border-red-700 transition-colors';
                        card.innerHTML = `
                            <h4 class="font-bold text-lg">${monster.name}</h4>
                            <p class="text-sm text-gray-400">${monster.size} ${monster.type}</p>
                            <p class="text-xs text-gray-500 mt-1">CR ${monster.cr} (${monster.xp} XP)</p>
                            <p class="text-xs text-yellow-400">AC ${monster.ac} | HP ${monster.hp}</p>
                        `;
                        
                        card.addEventListener('click', () => {
                            displayMonsterDetails(monster);
                        });
                        
                        monsterList.appendChild(card);
                    });
                }
                
                function displayMonsterDetails(monster) {
                    const abilities = monster.abilities || {};
                    
                    monsterDetails.innerHTML = `
                        <div class="space-y-4">
                            <div>
                                <h3 class="font-title text-2xl text-red-400">${monster.name}</h3>
                                <p class="text-gray-400">${monster.size} ${monster.type}, ${monster.alignment}</p>
                            </div>
                            
                            <div class="grid grid-cols-3 gap-4 text-sm">
                                <div><strong>Armor Class:</strong> ${monster.ac}</div>
                                <div><strong>Hit Points:</strong> ${monster.hp} (${monster.hitDice})</div>
                                <div><strong>Speed:</strong> ${Object.entries(monster.speed).map(([k,v]) => `${k} ${v}ft`).join(', ')}</div>
                            </div>
                            
                            <div class="grid grid-cols-6 gap-2 text-center text-sm">
                                <div><strong>STR</strong><br>${abilities.str || 10} (${calculateModifier(abilities.str || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.str || 10)})</div>
                                <div><strong>DEX</strong><br>${abilities.dex || 10} (${calculateModifier(abilities.dex || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.dex || 10)})</div>
                                <div><strong>CON</strong><br>${abilities.con || 10} (${calculateModifier(abilities.con || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.con || 10)})</div>
                                <div><strong>INT</strong><br>${abilities.int || 10} (${calculateModifier(abilities.int || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.int || 10)})</div>
                                <div><strong>WIS</strong><br>${abilities.wis || 10} (${calculateModifier(abilities.wis || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.wis || 10)})</div>
                                <div><strong>CHA</strong><br>${abilities.cha || 10} (${calculateModifier(abilities.cha || 10) >= 0 ? '+' : ''}${calculateModifier(abilities.cha || 10)})</div>
                            </div>
                            
                            <div class="text-sm">
                                <div><strong>Senses:</strong> ${monster.senses}</div>
                                <div><strong>Languages:</strong> ${monster.languages}</div>
                                <div><strong>Challenge:</strong> ${monster.cr} (${monster.xp} XP)</div>
                            </div>
                            
                            ${monster.traits?.length ? `
                                <div>
                                    <h4 class="font-bold text-lg mb-2">Traits</h4>
                                    ${monster.traits.map(trait => `
                                        <div class="mb-2">
                                            <strong>${trait.name}.</strong> ${trait.description}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                            
                            ${monster.actions?.length ? `
                                <div>
                                    <h4 class="font-bold text-lg mb-2">Actions</h4>
                                    ${monster.actions.map(action => `
                                        <div class="mb-2">
                                            <strong>${action.name}.</strong> ${action.description}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                            
                            ${monster.legendary_actions?.length ? `
                                <div>
                                    <h4 class="font-bold text-lg mb-2">Legendary Actions</h4>
                                    <div class="text-sm text-gray-300">
                                        ${monster.legendary_actions.map(action => `<div class="mb-1">• ${action}</div>`).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div class="flex gap-2 mt-4">
                                <button onclick="addToCombat('${monster.name}')" class="btn font-title py-2 px-4 rounded-md">Add to Combat</button>
                                <button onclick="rollMonsterInitiative('${monster.name}')" class="btn font-title py-2 px-4 rounded-md">Roll Initiative</button>
                            </div>
                        </div>
                    `;
                }
                
                function filterMonsters() {
                    const searchTerm = searchInput.value.toLowerCase();
                    const crFilter_val = crFilter.value;
                    const typeFilter_val = typeFilter.value;
                    
                    let filtered = Object.values(DND_DATA.monsters).filter(monster => {
                        const matchesSearch = monster.name.toLowerCase().includes(searchTerm);
                        const matchesCR = !crFilter_val || monster.cr === crFilter_val;
                        const matchesType = !typeFilter_val || monster.type === typeFilter_val;
                        
                        return matchesSearch && matchesCR && matchesType;
                    });
                    
                    displayMonsters(filtered);
                }
                
                searchInput?.addEventListener('input', filterMonsters);
                crFilter?.addEventListener('change', filterMonsters);
                typeFilter?.addEventListener('change', filterMonsters);
                
                // Initial display
                displayMonsters();
            }
            
            // ===== AI INTEGRATION SYSTEM =====
            let aiConfig = {
                model: localStorage.getItem('ai_model') || 'gemini-2.5-flash',
                isConfigured: true // API key is securely stored server-side
            };
            
            function setupAISystem() {
                const modelSelect = document.getElementById('ai-model');
                const chatDiv = document.getElementById('ai-chat');
                const chatInput = document.getElementById('ai-input');
                const statusDiv = document.getElementById('ai-status');
                
                // Load saved config
                if (aiConfig.model) modelSelect.value = aiConfig.model;
                
                // Save model selection on change
                modelSelect?.addEventListener('change', (e) => {
                    aiConfig.model = e.target.value;
                    localStorage.setItem('ai_model', aiConfig.model);
                });
                
                // Test AI connection
                document.getElementById('test-ai')?.addEventListener('click', async () => {
                    statusDiv.innerHTML = '🟡 Testing...';
                    statusDiv.className = 'text-yellow-400 font-bold';
                    
                    try {
                        const response = await callGeminiAI('Say hello and confirm you are working as a D&D assistant.');
                        addChatMessage('Gemini AI', response, 'success');
                        statusDiv.innerHTML = '🟢 Connected';
                        statusDiv.className = 'text-green-400 font-bold';
                    } catch (error) {
                        addChatMessage('System', `AI connection failed: ${error.message}`, 'error');
                        statusDiv.innerHTML = '🔴 Error';
                        statusDiv.className = 'text-red-400 font-bold';
                    }
                });
                
                // Chat functionality
                const sendMessage = async () => {
                    const message = chatInput.value.trim();
                    if (!message) return;
                    
                    addChatMessage('You', message, 'user');
                    chatInput.value = '';
                    
                    try {
                        const response = await callGeminiAI(message);
                        addChatMessage('Gemini AI', response, 'ai');
                    } catch (error) {
                        addChatMessage('System', `Error: ${error.message}`, 'error');
                    }
                };
                
                document.getElementById('send-ai')?.addEventListener('click', sendMessage);
                chatInput?.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') sendMessage();
                });
                
                // Quick AI tools
                document.getElementById('ai-npc')?.addEventListener('click', () => generateAIContent('Generate a unique NPC with name, appearance, personality, and a secret.'));
                document.getElementById('ai-description')?.addEventListener('click', () => generateAIContent('Generate a vivid description of a fantasy location.'));
                document.getElementById('ai-plot')?.addEventListener('click', () => generateAIContent('Generate an interesting plot hook for a D&D adventure.'));
                document.getElementById('ai-dialogue')?.addEventListener('click', () => generateAIContent('Generate some interesting NPC dialogue.'));
                document.getElementById('ai-riddle')?.addEventListener('click', () => generateAIContent('Generate a clever riddle for players to solve.'));
                document.getElementById('ai-lore')?.addEventListener('click', () => generateAIContent('Generate interesting lore about a fantasy kingdom.'));
                
                function addChatMessage(sender, message, type) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `mb-2 p-2 rounded ${
                        type === 'user' ? 'bg-blue-800' : 
                        type === 'ai' ? 'bg-green-800' : 
                        type === 'error' ? 'bg-red-800' : 'bg-gray-700'
                    }`;
                    
                    messageDiv.innerHTML = `
                        <div class="font-bold text-sm">${sender}</div>
                        <div class="text-sm">${message}</div>
                        <div class="text-xs text-gray-400">${new Date().toLocaleTimeString()}</div>
                    `;
                    
                    chatDiv.appendChild(messageDiv);
                    chatDiv.scrollTop = chatDiv.scrollHeight;
                }
                
                async function generateAIContent(prompt) {
                    try {
                        const response = await callGeminiAI(prompt);
                        addChatMessage('Gemini AI', response, 'ai');
                    } catch (error) {
                        addChatMessage('System', `Error: ${error.message}`, 'error');
                    }
                }
                
                async function callGeminiAI(message) {
                    const response = await fetch('/api/gemini', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: aiConfig.model,
                            message: message,
                            systemPrompt: 'You are a helpful D&D dungeon master assistant. Provide creative, concise, and useful responses for tabletop gaming. Format your responses with proper markdown for readability.'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    return data.response || 'No response generated';
                }
            }
            
            // ===== CHARACTER CREATION SYSTEM =====
            function setupCharacterCreation() {
                let currentCharacter = {
                    name: '',
                    race: '',
                    class: '',
                    background: '',
                    level: 1,
                    abilities: {str: 8, dex: 8, con: 8, int: 8, wis: 8, cha: 8},
                    hp: 0,
                    ac: 10,
                    equipment: [],
                    spells: [],
                    proficiencies: []
                };
                
                document.getElementById('new-character-btn')?.addEventListener('click', () => {
                    showCharacterCreationModal();
                });
                
                document.getElementById('random-character-btn')?.addEventListener('click', () => {
                    generateRandomCharacter();
                });
                
                function showCharacterCreationModal() {
                    const modalContent = document.getElementById('modal-content');
                    modalContent.innerHTML = `
                        <h3 class="font-title text-2xl mb-4">Create New Character</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="font-bold block mb-1">Character Name:</label>
                                <input type="text" id="char-name" class="input-field w-full p-2" placeholder="Enter character name">
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="font-bold block mb-1">Race:</label>
                                    <select id="char-race" class="input-field w-full p-2">
                                        ${Object.keys(DND_DATA.races).map(race => `<option value="${race}">${race}</option>`).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label class="font-bold block mb-1">Class:</label>
                                    <select id="char-class" class="input-field w-full p-2">
                                        ${Object.keys(DND_DATA.classes).map(cls => `<option value="${cls}">${cls}</option>`).join('')}
                                    </select>
                                </div>
                            </div>
                            <div>
                                <label class="font-bold block mb-1">Background:</label>
                                <select id="char-background" class="input-field w-full p-2">
                                    ${Object.keys(DND_DATA.backgrounds).map(bg => `<option value="${bg}">${bg}</option>`).join('')}
                                </select>
                            </div>
                            <div class="grid grid-cols-3 gap-2">
                                <div><label class="font-bold">STR:</label><input type="number" id="char-str" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                                <div><label class="font-bold">DEX:</label><input type="number" id="char-dex" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                                <div><label class="font-bold">CON:</label><input type="number" id="char-con" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                                <div><label class="font-bold">INT:</label><input type="number" id="char-int" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                                <div><label class="font-bold">WIS:</label><input type="number" id="char-wis" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                                <div><label class="font-bold">CHA:</label><input type="number" id="char-cha" class="input-field w-full p-1" value="10" min="3" max="18"></div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="rollAbilityScores()" class="btn font-title py-2 px-4 rounded-md">Roll 4d6 Drop Lowest</button>
                                <button onclick="standardArray()" class="btn font-title py-2 px-4 rounded-md">Standard Array</button>
                            </div>
                            <button onclick="createCharacter()" class="btn font-title w-full py-3 rounded-md">Create Character</button>
                        </div>
                    `;
                    
                    document.getElementById('modal-overlay').style.display = 'flex';
                }
                
                window.rollAbilityScores = function() {
                    const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
                    abilities.forEach(ability => {
                        const rolls = Array.from({length: 4}, () => Math.floor(Math.random() * 6) + 1);
                        rolls.sort((a, b) => b - a);
                        const total = rolls.slice(0, 3).reduce((sum, roll) => sum + roll, 0);
                        document.getElementById(`char-${ability}`).value = total;
                    });
                };
                
                window.standardArray = function() {
                    const standardScores = [15, 14, 13, 12, 10, 8];
                    const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
                    abilities.forEach((ability, index) => {
                        document.getElementById(`char-${ability}`).value = standardScores[index];
                    });
                };
                
                window.createCharacter = function() {
                    const character = {
                        id: Date.now(),
                        name: document.getElementById('char-name').value || 'Unnamed Character',
                        race: document.getElementById('char-race').value,
                        class: document.getElementById('char-class').value,
                        background: document.getElementById('char-background').value,
                        level: 1,
                        abilities: {
                            str: parseInt(document.getElementById('char-str').value),
                            dex: parseInt(document.getElementById('char-dex').value),
                            con: parseInt(document.getElementById('char-con').value),
                            int: parseInt(document.getElementById('char-int').value),
                            wis: parseInt(document.getElementById('char-wis').value),
                            cha: parseInt(document.getElementById('char-cha').value)
                        },
                        created: new Date().toLocaleDateString()
                    };
                    
                    // Calculate derived stats
                    const classData = DND_DATA.classes[character.class];
                    const conMod = calculateModifier(character.abilities.con);
                    character.hp = classData.hitDie + conMod;
                    character.ac = 10 + calculateModifier(character.abilities.dex);
                    
                    // Save character
                    gameState.characters.push(character);
                    saveData();
                    
                    document.getElementById('modal-overlay').style.display = 'none';
                    refreshCharacterList();
                };
                
                function generateRandomCharacter() {
                    const races = Object.keys(DND_DATA.races);
                    const classes = Object.keys(DND_DATA.classes);
                    const backgrounds = Object.keys(DND_DATA.backgrounds);
                    const names = DND_DATA.generators.npcs.names.human_male.concat(DND_DATA.generators.npcs.names.human_female);
                    
                    const character = {
                        id: Date.now(),
                        name: names[Math.floor(Math.random() * names.length)],
                        race: races[Math.floor(Math.random() * races.length)],
                        class: classes[Math.floor(Math.random() * classes.length)],
                        background: backgrounds[Math.floor(Math.random() * backgrounds.length)],
                        level: 1,
                        abilities: {
                            str: rollAbilityScore(),
                            dex: rollAbilityScore(),
                            con: rollAbilityScore(),
                            int: rollAbilityScore(),
                            wis: rollAbilityScore(),
                            cha: rollAbilityScore()
                        },
                        created: new Date().toLocaleDateString()
                    };
                    
                    const classData = DND_DATA.classes[character.class];
                    const conMod = calculateModifier(character.abilities.con);
                    character.hp = classData.hitDie + conMod;
                    character.ac = 10 + calculateModifier(character.abilities.dex);
                    
                    gameState.characters.push(character);
                    saveData();
                    refreshCharacterList();
                }
                
                function rollAbilityScore() {
                    const rolls = Array.from({length: 4}, () => Math.floor(Math.random() * 6) + 1);
                    rolls.sort((a, b) => b - a);
                    return rolls.slice(0, 3).reduce((sum, roll) => sum + roll, 0);
                }
                
                function refreshCharacterList() {
                    const container = document.getElementById('character-list');
                    if (!container) return;
                    
                    container.innerHTML = '';
                    
                    gameState.characters.forEach(character => {
                        const div = document.createElement('div');
                        div.className = 'card p-4 cursor-pointer hover:border-red-700';
                        div.innerHTML = `
                            <div class="flex justify-between items-center">
                                <div>
                                    <h4 class="font-bold">${character.name}</h4>
                                    <p class="text-sm text-gray-400">Level ${character.level} ${character.race} ${character.class}</p>
                                    <p class="text-xs text-gray-500">${character.background} • Created ${character.created}</p>
                                </div>
                                <div class="text-right text-sm">
                                    <div>HP: ${character.hp}</div>
                                    <div>AC: ${character.ac}</div>
                                </div>
                            </div>
                        `;
                        
                        div.addEventListener('click', () => {
                            showCharacterSheet(character);
                        });
                        
                        container.appendChild(div);
                    });
                }
                
                function showCharacterSheet(character) {
                    const modalContent = document.getElementById('modal-content');
                    modalContent.innerHTML = `
                        <h3 class="font-title text-2xl mb-4">${character.name}</h3>
                        <div class="space-y-4">
                            <div class="grid grid-cols-3 gap-4 text-center">
                                <div><strong>Race:</strong><br>${character.race}</div>
                                <div><strong>Class:</strong><br>${character.class}</div>
                                <div><strong>Background:</strong><br>${character.background}</div>
                            </div>
                            
                            <div class="grid grid-cols-3 gap-4 text-center">
                                <div><strong>Level:</strong><br>${character.level}</div>
                                <div><strong>Hit Points:</strong><br>${character.hp}</div>
                                <div><strong>Armor Class:</strong><br>${character.ac}</div>
                            </div>
                            
                            <div class="grid grid-cols-6 gap-2 text-center text-sm">
                                <div><strong>STR</strong><br>${character.abilities.str}<br>(${calculateModifier(character.abilities.str) >= 0 ? '+' : ''}${calculateModifier(character.abilities.str)})</div>
                                <div><strong>DEX</strong><br>${character.abilities.dex}<br>(${calculateModifier(character.abilities.dex) >= 0 ? '+' : ''}${calculateModifier(character.abilities.dex)})</div>
                                <div><strong>CON</strong><br>${character.abilities.con}<br>(${calculateModifier(character.abilities.con) >= 0 ? '+' : ''}${calculateModifier(character.abilities.con)})</div>
                                <div><strong>INT</strong><br>${character.abilities.int}<br>(${calculateModifier(character.abilities.int) >= 0 ? '+' : ''}${calculateModifier(character.abilities.int)})</div>
                                <div><strong>WIS</strong><br>${character.abilities.wis}<br>(${calculateModifier(character.abilities.wis) >= 0 ? '+' : ''}${calculateModifier(character.abilities.wis)})</div>
                                <div><strong>CHA</strong><br>${character.abilities.cha}<br>(${calculateModifier(character.abilities.cha) >= 0 ? '+' : ''}${calculateModifier(character.abilities.cha)})</div>
                            </div>
                            
                            <div class="flex gap-2">
                                <button onclick="addToParty('${character.id}')" class="btn font-title py-2 px-4 rounded-md">Add to Party</button>
                                <button onclick="deleteCharacter('${character.id}')" class="btn font-title py-2 px-4 rounded-md bg-red-700">Delete</button>
                            </div>
                        </div>
                    `;
                    
                    document.getElementById('modal-overlay').style.display = 'flex';
                }
                
                window.addToParty = function(characterId) {
                    const character = gameState.characters.find(c => c.id.toString() === characterId);
                    if (character && !gameState.currentSession.party.find(p => p.id === character.id)) {
                        gameState.currentSession.party.push(character);
                        saveData();
                        refreshPartyDisplay();
                        document.getElementById('modal-overlay').style.display = 'none';
                    }
                };
                
                window.deleteCharacter = function(characterId) {
                    if (confirm('Are you sure you want to delete this character?')) {
                        gameState.characters = gameState.characters.filter(c => c.id.toString() !== characterId);
                        saveData();
                        refreshCharacterList();
                        document.getElementById('modal-overlay').style.display = 'none';
                    }
                };
                
                // Initialize character list
                refreshCharacterList();
            }
            
            // ===== ENCOUNTER BUILDER SYSTEM =====
            function setupEncounterBuilder() {
                document.getElementById('build-encounter')?.addEventListener('click', () => {
                    buildEncounter();
                });
                
                function buildEncounter() {
                    const partyLevel = parseInt(document.getElementById('party-level').value) || 1;
                    const partySize = parseInt(document.getElementById('party-size').value) || 4;
                    const difficulty = document.getElementById('encounter-difficulty').value || 'medium';
                    
                    const xpThresholds = getXPThresholds(partyLevel, partySize, difficulty);
                    const availableMonsters = Object.values(DND_DATA.monsters).filter(monster => {
                        const cr = parseFloat(monster.cr.replace('1/', '0.'));
                        return cr <= partyLevel + 2; // Don't include monsters too powerful
                    });
                    
                    const encounter = generateEncounter(availableMonsters, xpThresholds, partySize);
                    displayEncounter(encounter, xpThresholds);
                }
                
                function getXPThresholds(level, size, difficulty) {
                    const perCharacter = {
                        1: {easy: 25, medium: 50, hard: 75, deadly: 100},
                        2: {easy: 50, medium: 100, hard: 150, deadly: 200},
                        3: {easy: 75, medium: 150, hard: 225, deadly: 400},
                        4: {easy: 125, medium: 250, hard: 375, deadly: 500},
                        5: {easy: 250, medium: 500, hard: 750, deadly: 1100}
                    }[level] || {easy: 250, medium: 500, hard: 750, deadly: 1100};
                    
                    return {
                        target: perCharacter[difficulty] * size,
                        max: perCharacter.deadly * size
                    };
                }
                
                function generateEncounter(monsters, thresholds, partySize) {
                    const encounter = [];
                    let currentXP = 0;
                    let attempts = 0;
                    
                    while (currentXP < thresholds.target && attempts < 20) {
                        const remainingXP = thresholds.target - currentXP;
                        const suitableMonsters = monsters.filter(m => m.xp <= remainingXP);
                        
                        if (suitableMonsters.length === 0) break;
                        
                        const monster = suitableMonsters[Math.floor(Math.random() * suitableMonsters.length)];
                        const count = Math.min(
                            Math.floor(remainingXP / monster.xp),
                            Math.floor(Math.random() * 3) + 1
                        );
                        
                        if (count > 0) {
                            encounter.push({monster, count});
                            currentXP += monster.xp * count;
                        }
                        
                        attempts++;
                    }
                    
                    return {creatures: encounter, totalXP: currentXP};
                }
                
                function displayEncounter(encounter, thresholds) {
                    const container = document.getElementById('encounter-results');
                    if (!container) return;
                    
                    const difficultyRating = encounter.totalXP <= thresholds.target * 0.8 ? 'Easy' :
                                           encounter.totalXP <= thresholds.target * 1.5 ? 'Medium' :
                                           encounter.totalXP <= thresholds.target * 2 ? 'Hard' : 'Deadly';
                    
                    container.innerHTML = `
                        <h4 class="font-bold text-lg mb-2">Generated Encounter</h4>
                        <div class="mb-2">
                            <span class="font-bold">Difficulty:</span> ${difficultyRating}
                            <span class="ml-4 font-bold">Total XP:</span> ${encounter.totalXP}
                        </div>
                        <div class="space-y-2">
                            ${encounter.creatures.map(({monster, count}) => `
                                <div class="flex justify-between items-center p-2 bg-gray-700 rounded">
                                    <span>${count}x ${monster.name}</span>
                                    <span class="text-sm text-gray-400">CR ${monster.cr} (${monster.xp * count} XP)</span>
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="addEncounterToCombat()" class="btn font-title w-full py-2 rounded-md mt-4">Add to Combat</button>
                    `;
                    
                    // Store encounter for later use
                    window.currentEncounter = encounter;
                }
                
                window.addEncounterToCombat = function() {
                    if (window.currentEncounter) {
                        window.currentEncounter.creatures.forEach(({monster, count}) => {
                            for (let i = 0; i < count; i++) {
                                combat.addParticipant({...monster, name: `${monster.name} ${i + 1}`});
                            }
                        });
                        showTab('combat');
                        combat.updateUI();
                    }
                };
            }
            
            // ===== PARTY MANAGEMENT =====
            function refreshPartyDisplay() {
                const container = document.getElementById('party-display');
                if (!container) return;
                
                container.innerHTML = '';
                
                if (gameState.currentSession.party.length === 0) {
                    container.innerHTML = '<p class="text-gray-400">No party members. Add characters from the Characters tab.</p>';
                    return;
                }
                
                gameState.currentSession.party.forEach(character => {
                    const div = document.createElement('div');
                    div.className = 'card p-4';
                    div.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="font-bold">${character.name}</h4>
                                <p class="text-sm text-gray-400">Level ${character.level} ${character.race} ${character.class}</p>
                            </div>
                            <div class="text-right text-sm">
                                <div>HP: ${character.hp}</div>
                                <div>AC: ${character.ac}</div>
                            </div>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }
            
            // ===== RANDOM GENERATORS =====
            function setupGenerators() {
                document.getElementById('gen-treasure')?.addEventListener('click', () => generateTreasure());
                document.getElementById('gen-trap')?.addEventListener('click', () => generateTrap());
                document.getElementById('gen-puzzle')?.addEventListener('click', () => generatePuzzle());
                document.getElementById('gen-weather')?.addEventListener('click', () => generateWeather());
                document.getElementById('gen-rumor')?.addEventListener('click', () => generateRumor());
                document.getElementById('gen-tavern')?.addEventListener('click', () => generateTavern());
                
                function addGeneratorOutput(title, content) {
                    const container = document.getElementById('generator-output');
                    if (!container) return;
                    
                    const timestamp = new Date().toLocaleTimeString();
                    const div = document.createElement('div');
                    div.className = 'border-b border-gray-700 pb-2 mb-2';
                    div.innerHTML = `
                        <div class="font-bold text-yellow-400">${title}</div>
                        <div class="text-sm">${content}</div>
                        <div class="text-xs text-gray-400">[${timestamp}]</div>
                    `;
                    container.insertBefore(div, container.firstChild);
                }
                
                function generateTreasure() {
                    const items = DND_DATA.generators.treasures.magic_items.common;
                    const item = items[Math.floor(Math.random() * items.length)];
                    const coins = `${Math.floor(Math.random() * 100) + 1} gold pieces`;
                    addGeneratorOutput('Treasure Found', `${item} and ${coins}`);
                }
                
                function generateTrap() {
                    const traps = [
                        'Poison dart trap (DC 15 Investigation to find, DC 15 Dexterity save or take 1d4 poison damage)',
                        'Pit trap (DC 15 Perception to notice, DC 15 Dexterity save or fall 10 feet for 1d6 damage)',
                        'Crossbow trap (triggered by pressure plate, +6 to hit, 1d8+3 piercing damage)',
                        'Falling net (DC 15 Dexterity save or be restrained)',
                        'Fire jet (DC 15 Dexterity save or take 2d6 fire damage)'
                    ];
                    const trap = traps[Math.floor(Math.random() * traps.length)];
                    addGeneratorOutput('Trap Generated', trap);
                }
                
                function generatePuzzle() {
                    const puzzles = [
                        'A door with four colored gems that must be pressed in the order of the rainbow',
                        'A riddle: "I have cities, but no houses. I have mountains, but no trees. I have water, but no fish. What am I?" (Answer: A map)',
                        'A statue with moveable arms that must point to the correct constellations',
                        'A musical lock that requires playing a specific melody',
                        'A weight-based puzzle where items must be placed on scales to balance exactly'
                    ];
                    const puzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
                    addGeneratorOutput('Puzzle Created', puzzle);
                }
                
                function generateWeather() {
                    const weather = ['Clear skies', 'Light rain', 'Heavy storm', 'Thick fog', 'Snow flurries', 'Blazing heat', 'Howling winds', 'Overcast'];
                    const temperature = ['Frigid', 'Cold', 'Cool', 'Mild', 'Warm', 'Hot', 'Sweltering'];
                    const result = `${weather[Math.floor(Math.random() * weather.length)]}, ${temperature[Math.floor(Math.random() * temperature.length)]} temperature`;
                    addGeneratorOutput('Weather', result);
                }
                
                function generateRumor() {
                    const rumors = [
                        'Strange lights have been seen in the old ruins north of town',
                        'The mayor\'s daughter has been acting oddly since visiting the forest',
                        'Merchant caravans have been disappearing on the eastern road',
                        'The local priest claims to have received divine visions',
                        'A mysterious stranger has been asking questions about ancient artifacts',
                        'The well water has turned an unusual color recently'
                    ];
                    const rumor = rumors[Math.floor(Math.random() * rumors.length)];
                    addGeneratorOutput('Rumor Overheard', rumor);
                }
                
                function generateTavern() {
                    const taverns = {
                        names: ['The Prancing Pony', 'The Dragon\'s Rest', 'The Weary Traveler', 'The Golden Goblet', 'The Rusty Anchor'],
                        keepers: ['A jolly halfling with a booming laugh', 'A stern dwarf with magnificent braids', 'A mysterious elf who never ages', 'A friendly human couple', 'A gruff orc with a heart of gold'],
                        specials: ['Roasted boar with ale', 'Dragon pepper stew', 'Honey cakes and wine', 'Fresh fish and bread', 'Exotic spiced meat']
                    };
                    
                    const name = taverns.names[Math.floor(Math.random() * taverns.names.length)];
                    const keeper = taverns.keepers[Math.floor(Math.random() * taverns.keepers.length)];
                    const special = taverns.specials[Math.floor(Math.random() * taverns.specials.length)];
                    
                    addGeneratorOutput('Tavern Details', `${name} - Run by ${keeper}. Today's special: ${special}`);
                }
            }
            
            // ===== GLOBAL FUNCTIONS FOR INLINE EVENTS =====
            window.addToCombat = function(monsterName) {
                const monster = DND_DATA.monsters[monsterName];
                if (monster) {
                    combat.addParticipant(monster);
                    showTab('combat');
                    combat.updateUI();
                }
            };
            
            window.rollMonsterInitiative = function(monsterName) {
                const monster = DND_DATA.monsters[monsterName];
                if (monster) {
                    const dexMod = calculateModifier(monster.abilities?.dex || 10);
                    const roll = rollDice(20, 1, dexMod);
                    const resultsDiv = document.getElementById('dice-results');
                    if (resultsDiv) {
                        const timestamp = new Date().toLocaleTimeString();
                        const resultDiv = document.createElement('div');
                        resultDiv.className = 'border-b border-gray-700 pb-2 mb-2';
                        resultDiv.innerHTML = `
                            <div class="flex justify-between items-center">
                                <span class="font-bold text-blue-400">${monster.name} Initiative</span>
                                <span class="text-2xl text-yellow-400">${roll.total}</span>
                            </div>
                            <div class="text-xs text-gray-400">[${timestamp}] d20+${dexMod} (${roll.rolls[0]}+${dexMod})</div>
                        `;
                        resultsDiv.insertBefore(resultDiv, resultsDiv.firstChild);
                    }
                    showTab('dice');
                }
            };
            
            // ===== MODAL MANAGEMENT =====
            document.getElementById('modal-close')?.addEventListener('click', () => {
                document.getElementById('modal-overlay').style.display = 'none';
            });
            
            // Initialize all systems
            setupDiceRoller();
            setupSpellDatabase();
            setupMonsterDatabase();
            setupAISystem();
            setupCharacterCreation();
            setupEncounterBuilder();
            setupGenerators();
            
            // Initialize displays
            refreshPartyDisplay();
            
            // ===== COMBAT SETTINGS PERSISTENCE =====
            function loadCombatSettings() {
                const savedSettings = localStorage.getItem('dnd_combat_settings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    
                    // Update combat manager settings
                    if (combat && combat.settings) {
                        combat.settings.advancedDiagonals = settings.advancedDiagonals || false;
                        combat.settings.criticalDeathSaves = settings.criticalDeathSaves !== false; // Default true
                    }
                    
                    // Update UI checkboxes
                    const advancedDiagonalsCheckbox = document.getElementById('setting-advanced-diagonals');
                    const criticalDeathSavesCheckbox = document.getElementById('setting-critical-death-saves');
                    
                    if (advancedDiagonalsCheckbox) {
                        advancedDiagonalsCheckbox.checked = settings.advancedDiagonals || false;
                    }
                    if (criticalDeathSavesCheckbox) {
                        criticalDeathSavesCheckbox.checked = settings.criticalDeathSaves !== false;
                    }
                }
            }
            
            function saveCombatSettings() {
                const advancedDiagonalsCheckbox = document.getElementById('setting-advanced-diagonals');
                const criticalDeathSavesCheckbox = document.getElementById('setting-critical-death-saves');
                
                const settings = {
                    advancedDiagonals: advancedDiagonalsCheckbox?.checked || false,
                    criticalDeathSaves: criticalDeathSavesCheckbox?.checked !== false
                };
                
                // Update combat manager settings
                if (combat && combat.settings) {
                    combat.settings.advancedDiagonals = settings.advancedDiagonals;
                    combat.settings.criticalDeathSaves = settings.criticalDeathSaves;
                }
                
                // Save to localStorage
                localStorage.setItem('dnd_combat_settings', JSON.stringify(settings));
                
                console.log('⚙️ Combat settings saved:', settings);
            }
            
            // Load settings on page load
            setTimeout(() => {
                loadCombatSettings();
            }, 500);
            
            // Add event listeners for settings changes
            document.getElementById('setting-advanced-diagonals')?.addEventListener('change', saveCombatSettings);
            document.getElementById('setting-critical-death-saves')?.addEventListener('change', saveCombatSettings);
            
            // Initialize with session tab
            showTab('session');
            
            console.log('🎲 D&D Ultimate Helper loaded!');
            console.log('📊 Comprehensive Database loaded:');
            console.log('  •', Object.keys(DND_DATA.monsters).length, 'monsters');
            console.log('  •', Object.keys(DND_DATA.spells.cantrips).length, 'cantrips');
            console.log('  •', Object.keys(DND_DATA.spells.level1).length, '1st level spells');
            console.log('  •', Object.keys(DND_DATA.spells.level2 || {}).length, '2nd level spells');
            console.log('  •', Object.keys(DND_DATA.spells.level3 || {}).length, '3rd level spells');
            console.log('  •', Object.keys(DND_DATA.spells.level4 || {}).length, '4th level spells');
            console.log('  •', Object.keys(DND_DATA.spells.level5 || {}).length, '5th level spells');
            console.log('  •', Object.keys(DND_DATA.races).length, 'races');
            console.log('  •', Object.keys(DND_DATA.classes).length, 'classes');
            console.log('  •', Object.keys(DND_DATA.backgrounds).length, 'backgrounds');
            console.log('  •', Object.keys(DND_DATA.equipment.weapons).length, 'weapons');
            console.log('  •', Object.keys(DND_DATA.equipment.armor).length, 'armor pieces');
            console.log('🚀 All systems initialized: Combat, Dice, Spells, Monsters, AI, Characters, Encounters, Generators!');
            console.log('🏰 Ultimate D&D Helper ready for epic adventures!');
            console.log('📦 Total database size:', JSON.stringify(DND_DATA).length, 'characters');
        });
    </script>
    
    <!-- Loading indicator -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" style="display: none;">
        <div class="bg-gray-800 p-8 rounded-lg text-center">
            <div class="loader mx-auto mb-4"></div>
            <p class="text-gray-300">Processing...</p>
        </div>
    </div>
    
    <!-- Modal for various popups -->
    <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" style="display: none;">
        <div class="bg-gray-800 p-6 rounded-lg max-w-2xl max-h-[80vh] overflow-y-auto">
            <div id="modal-content"></div>
            <div class="flex justify-end mt-4">
                <button id="modal-close" class="btn font-title py-2 px-4 rounded-md">Close</button>
            </div>
        </div>
    </div>
</body>
</html>
